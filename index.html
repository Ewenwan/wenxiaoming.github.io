<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="Kevin Wen&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Kevin Wen&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kevin Wen&#39;s Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Kevin Wen's Blog</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kevin Wen's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/15/clDNN Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/15/clDNN Introduction/" itemprop="url">clDNN Introduction</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-15T20:20:31+09:00">
                2020-03-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2020/03/15/clDNN Introduction/" class="leancloud_visitors" data-flag-title="clDNN Introduction">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-总体结构"><a href="#0x1-总体结构" class="headerlink" title="0x1 总体结构"></a>0x1 总体结构</h1><p>clDNN(Compute Library for Deep Neural Networks)是采用OpenCL来加速DNN(Deep Neural Networks)的framework。目标平台是Intel® HD and Iris™ Pro Graphics。clDNN目前已经是Intel OpenVINO的一部分。OpenVINO还包括了其它各种硬件平台的加速库，如CPU上的加速库mklDNN等。clDNN当然也可以改造成在NVIDIA和AMD的GPU上运行，虽然这个时候的性能可能需要进一步tuning。</p>
<p>clDNN对DNN中有关概念进行了抽象，其中有关数据类型的层次结构如下。</p>
<p><img src="/2020/03/15/clDNN Introduction/cldnn.png" alt=""></p>
<p>这些数据类型的定义简单说明如下。</p>
<p>Kernel - 算子计算的OpenCL实现。<br>Primitive - DNN中基本运算单元，如convolution, pooling, softmax等，也就是通常所说的算子。<br>Data - 特殊的算子，用来表示运算过程中的参数，如weights和biases, 也指DNN的输入和输出。<br>Engine - DNN中运行的加速器的类型，目前只有OpenCL engine一种。<br>Topology - 指DNN中的graph，其中包括了primitives, data和他们之间的关系。<br>Program - 位于Topology和Network之间(可选项)，是编译好的graph网络但是没有分配内存。<br>Network - 编译好的graph网络并且已经分配内存，可以运行，在编译网络的过程中，网络参数可以进行特殊的优化如fusing，data reordering等。</p>
<p>clDNN的执行<a href="https://intel.github.io/clDNN/index.html" target="_blank" rel="external">流程图</a>如下所示。</p>
<p><img src="/2020/03/15/clDNN Introduction/workflow.jpg" alt=""></p>
<p>执行过程包括下面的步骤<br>a.Create Engine.<br>b.Declare or define primitives parameters (weights and biases) if needed.<br>c.Create primitives. It is required to provide name for each primitive.<br>d.Create topology<br>e.Add primitives to topology<br>f.Build Network from topology<br>h.Set Inputs data<br>g.Execute Network</p>
<p>本文后续对这些过程进行详细的说明。</p>
<h1 id="0x2-LoadNetwork流程分析"><a href="#0x2-LoadNetwork流程分析" class="headerlink" title="0x2 LoadNetwork流程分析"></a>0x2 LoadNetwork流程分析</h1><p>   <img src="/2020/03/15/clDNN Introduction/loadnetwork.svg" alt=""><br>   LoadNetwork的执行流程如上图所示，下面详细来介绍一下其中涉及到的内容。</p>
<h2 id="0x21-kernel-selector"><a href="#0x21-kernel-selector" class="headerlink" title="0x21 kernel selector"></a>0x21 kernel selector</h2><p>  前面已经知道，clDNN是通过OpenCL来加速DNN的推理执行，就是说其中的算子是通过OpenCL来加速的，kernel就是指采用OpenCL内核实现的算子。<br>  kernel selector提供了如何选择最适合的kernel的接口，Primitive创建kernel的时候，调用kernel selector来得到最合适的kernel。</p>
<p>  上层不能直接操作OpenCL kernel，所以提供了对应的wrapper，这些wrapper都在下面这个目录中。<br>  inference-engine\thirdparty\clDNN\kernel_selector\core\actual_kernels<br>  另外wrapper还定义了kernel支持的输入和输出数据格式。</p>
<p>  对应的OpenCL kernel的定义都在这个目录下面。<br>  inference-engine\thirdparty\clDNN\kernel_selector\core\cl_kernels</p>
<p>  现在我们想知道OpenCL kernel是什么时候创建的呢？通过分析代码，我们可以知道OpenCL kernel的创建是在build_program的时候通过下面的循环来实现的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> compile_graph::run(program_impl&amp; p) &#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; node : p.get_processing_order()) &#123;</div><div class="line">        <span class="keyword">if</span> (!node-&gt;is_type&lt;internal_primitive&gt;() &amp;&amp; !node-&gt;is_type&lt;data&gt;()) &#123;</div><div class="line">            node-&gt;get_output_layout();</div><div class="line">            <span class="keyword">if</span> (!node-&gt;is_type&lt;data&gt;() &amp;&amp; !(node-&gt;is_type&lt;mutable_data&gt;() &amp;&amp; node-&gt;get_dependencies().empty())) &#123;</div><div class="line">                node-&gt;selected_impl = node-&gt;type()-&gt;choose_impl(p.get_engine(), *node);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码中selected_impl的定义为primitive_impl类型的std::shared_ptr变量。<br>上述函数会调用到下面的create()函数。<br>这个函数再通过调用kernel_selector.GetBestKernels来创建最合适的OpenCL kernel。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> primitive_impl* <span class="title">create</span><span class="params">(<span class="keyword">const</span> scale_node&amp; arg)</span> </span>&#123;</div><div class="line">    ......</div><div class="line">    ew_params.layoutBased = <span class="literal">true</span>;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span>&amp; kernel_selector = kernel_selector::eltwise_kernel_selector::Instance();</div><div class="line">    <span class="keyword">auto</span> best_kernels = kernel_selector.GetBestKernels(ew_params, ew_optional_params);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> scale = <span class="keyword">new</span> scale_gpu(arg, best_kernels[<span class="number">0</span>]);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> scale;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x22-primitive封装"><a href="#0x22-primitive封装" class="headerlink" title="0x22 primitive封装"></a>0x22 primitive封装</h2><p>primitive是对前面通过kernel selector取得的kernel的封装。<br>其中的primitive结构体都是通过typed_primitive_gpu_impl来定义的。</p>
<p>clDNN Library提供了下面这些<a href="https://intel.github.io/clDNN/index.html" target="_blank" rel="external">primitives</a>，</p>
<pre><code>Convolution
Fully connected (inner product)
Pooling
    average
    maximum
Normalization
    across channel
    within channel
    batch
Activation
    logistic
    tanh
    rectified linear unit (ReLU)
    softplus (softReLU)
    abs
    square
    sqrt
    linear
Softmax
Crop
Deconvolution
Depth concatenation
Eltwise
ROI pooling
Simpler NMS
Prior box
Detection output
</code></pre><p>通过对上述primitive的封装，clDNN提供了下面的topologies<br>    Alexnet<br>    Googlenet(v1-v3)<br>    ResNet<br>    VGG<br>    faster-rCNN and other.</p>
<h2 id="0x23-OpenCL接口的封装"><a href="#0x23-OpenCL接口的封装" class="headerlink" title="0x23 OpenCL接口的封装"></a>0x23 OpenCL接口的封装</h2><p>在目录inference-engine\thirdparty\clDNN\src\gpu\下面提供了OpenCL封装的代码，这些代码对OpenCL的底层api进行了封装，方便了clDNN其他模块的调用。</p>
<p>其中的gpu_queue类提供了对OpenCL command queue的封装，对外提供了command queue的创建和使用的接口。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">gpu_queue</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ......</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">uint32_t</span> id;</div><div class="line">    <span class="built_in">std</span>::weak_ptr&lt;gpu_toolkit&gt; _context;</div><div class="line">    cl::CommandQueue _command_queue;</div><div class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; _queue_counter&#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; _last_barrier&#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;events_pool&gt; _events_pool;</div><div class="line">    cl::Event _last_barrier_ev;</div><div class="line">    <span class="keyword">bool</span> _output_event = <span class="literal">false</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>gpu_toolkit类提供了OpenCL操作的统一接口，其他模块只需要调用gpu_toolkit就可以实现OpenCL的相关操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">gpu_toolkit</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;gpu_toolkit&gt; &#123;</div><div class="line">    ......</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    configuration _configuration;</div><div class="line">    cl::Device _device;</div><div class="line">    cl::Context _context;</div><div class="line">    cl_platform_id _platform_id;</div><div class="line">    device_info_internal _device_info;</div><div class="line">    <span class="keyword">bool</span> _neo_driver = <span class="literal">false</span>;</div><div class="line">    kernels_cache _kernels_cache;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">uint32_t</span>, gpu_queue&gt; _command_queues_w;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;rapidjson::Document&gt; _device_cache;</div><div class="line">    kernels_binaries_container _binaries;</div><div class="line">    <span class="keyword">bool</span> _serialize = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _extensions;</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ocl_logger</span>;</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ocl_logger&gt; _logger;</div><div class="line"></div><div class="line">    <span class="comment">// returns whether a barrier has been added</span></div><div class="line">    <span class="built_in">std</span>::<span class="function">ofstream&amp; <span class="title">open_log</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">get_device_version</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _device.getInfo&lt;CL_DEVICE_VERSION&gt;(); &#125;</div><div class="line"></div><div class="line">    <span class="comment">// void build_command_queues();</span></div><div class="line">    <span class="function">gpu_queue&amp; <span class="title">get_command_queue</span><span class="params">(<span class="keyword">uint32_t</span> id)</span></span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="0x24-graph-optimizer"><a href="#0x24-graph-optimizer" class="headerlink" title="0x24 graph optimizer"></a>0x24 graph optimizer</h2><p>在build_program的时候会初始化graph，然后执行graph优化，包括pre_optimize_graph和post_optimize_graph。<br>执行步骤都是在下面的build_program函数中完成的。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> program_impl::build_program(<span class="keyword">bool</span> is_internal) &#123;</div><div class="line">    init_graph();</div><div class="line">    &#123; pre_optimize_graph(is_internal); &#125;</div><div class="line">    run_graph_compilation();</div><div class="line">    &#123; post_optimize_graph(is_internal); &#125;</div><div class="line">    prepare_memory_dependencies();</div><div class="line">    engine-&gt;compile_program(*<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!is_internal)</div><div class="line">        prim_info = get_current_stage_info();</div><div class="line"></div><div class="line">    cleanup();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面来分析一下pre_optimize_graph和post_optimize_graph分别是如何对graph进行优化的。<br>graph优化是通过调用apply_opt_pass来实现的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apply_opt_pass&lt;trim_to_outputs&gt;();</div></pre></td></tr></table></figure>
<p>apply_opt_pass是模板函数，模板参数trim_to_outputs是继承于base_pass的优化pass。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">trim_to_outputs</span> :</span> <span class="keyword">public</span> base_pass &#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    trim_to_outputs() : base_pass(<span class="string">"trimmed"</span>) &#123;&#125;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(program_impl&amp; p)</span> override</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>模板函数apply_opt_pass的定义如下。在模板函数中生成Pass对象，Pass对象的基类是base_pass，然后调用pass_manager的run函数执行优化操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">apply_opt_pass</span><span class="params">(base_pass&amp; pass)</span> </span>&#123; pm-&gt;run(*<span class="keyword">this</span>, pass); &#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Pass</span>, <span class="title">typename</span>... <span class="title">Args</span>&gt;</span></div><div class="line"><span class="title">typename</span> <span class="title">std</span>::enable_if&lt;<span class="built_in">std</span>::is_base_of&lt;base_pass, Pass&gt;::value &amp;&amp;</div><div class="line">                        <span class="built_in">std</span>::is_constructible&lt;Pass, Args...&gt;::value&gt;::<span class="function">type</span></div><div class="line"><span class="title">apply_opt_pass</span><span class="params">(Args&amp;&amp;... args)</span> &#123;</div><div class="line">    <span class="keyword">auto</span> pass = Pass(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</div><div class="line">    apply_opt_pass(pass);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>pass_manager的run函数定义如下。在run函数里会调用优化pass的run函数来执行具体的优化操作。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> pass_manager::run(program_impl&amp; p, base_pass&amp; pass) &#123;</div><div class="line">    ......</div><div class="line">    pass.run(p);</div><div class="line">    ......</div><div class="line">    pass_count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x25-program-node创建"><a href="#0x25-program-node创建" class="headerlink" title="0x25 program node创建"></a>0x25 program node创建</h2><p>program_node的定义如下，每一个program_node和一个primitive_impl相对应，primitive_impl是前面提到的OpenCL kernel函数的封装。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">    Base class for all primitives which wraps API class and extends it to be used</div><div class="line">    in graph context.</div><div class="line">*/</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">program_node</span> &#123;</span></div><div class="line">    ......</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;primitive&gt; desc;</div><div class="line">    program_impl&amp; myprog;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;primitive_impl&gt; selected_impl;</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> valid_output_layout = <span class="literal">false</span>;</div><div class="line">    layout output_layout = layout(data_types::f32, format::bfyx, tensor());</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;program_node*&gt; dependencies;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;program_node*&gt; users;</div></pre></td></tr></table></figure>
<p>program_node的创建函数如下，创建好的node保存在nodes_map中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create all nodes from topology primitives, add dependencies among them and create inputs list</span></div><div class="line"><span class="keyword">void</span> program_impl::prepare_nodes(topology_impl <span class="keyword">const</span>&amp; topology) &#123;</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span>&amp; topo_map = topology.get_primitives();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; prim : topo_map) &#123;</div><div class="line">        get_or_create(prim.second);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;</div><div class="line"></div><div class="line">program_node&amp; program_impl::get_or_create(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;primitive&gt; prim) &#123;</div><div class="line">    <span class="keyword">auto</span> itr = nodes_map.lower_bound(prim-&gt;id);</div><div class="line">    <span class="keyword">if</span> (itr != nodes_map.end() &amp;&amp; itr-&gt;first == prim-&gt;id)</div><div class="line">        <span class="keyword">return</span> *itr-&gt;second;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> new_node = prim-&gt;type-&gt;create_node(*<span class="keyword">this</span>, prim);</div><div class="line">    nodes_map.insert(itr, &#123;prim-&gt;id, new_node&#125;);</div><div class="line">    <span class="keyword">return</span> *new_node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>typed_program_node是program_node的继承类，提供了对各种类型的program_node的封装。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">typed_program_node</span>&lt;activation&gt; :</span> <span class="keyword">public</span> typed_program_node_base&lt;activation&gt; &#123;</div><div class="line">    <span class="keyword">using</span> parent = typed_program_node_base&lt;activation&gt;;</div><div class="line">    typed_program_node(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;activation&gt; prim, program_impl&amp; prog) : parent(prim, prog) &#123;</div><div class="line">        support_padding_all(<span class="literal">true</span>);</div><div class="line">    &#125;</div><div class="line">    ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="0x3-Infer流程分析"><a href="#0x3-Infer流程分析" class="headerlink" title="0x3 Infer流程分析"></a>0x3 Infer流程分析</h1><p>前面网络加载好了以后，下面就开始真正的推理执行了，详细的流程如下。<br>   <img src="/2020/03/15/clDNN Introduction/infer.svg" alt=""><br>这个时候为了加速推理执行，如上图所示，采用了多线程的方法来提高执行的并行度，主线程把不同stage的task分配到不同的线程中去执行。<br>每个kernel执行的时候会调用enqueueNDRangeKernel来issue OpenCL驱动来执行计算。</p>
<p>我们知道一个推理网络执行的时候会有很多算子在执行，这些算子的执行在GPU上，如果每个算子执行完成以后都需要把结果从GPU读取到CPU中的话，效率会很低，这种执行模型如下所示，我们称之为sync执行模式。<br>   <img src="/2020/03/15/clDNN Introduction/execution_sync.png" alt=""></p>
<p>clDNN中采用的是如下图所示的async执行模型，各个算子之间的同步通过event来控制，每次算子执行完成以后，不需要把数据从GPU读取到CPU中。整个流程中只需要一次GPU buffer写入操作和一次GPU buffer读取操作。<br>   <img src="/2020/03/15/clDNN Introduction/execution_async.png" alt=""></p>
<p>下面是clDNN中enqueue kernel的代码。从代码中我们可以看到算子在每次执行enqueueNDRangeKernel的时候，需要等待一个算子执行完成的event被触发，这样算子之间的数据同步就不需要CPU的干预了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">event_impl::ptr gpu_queue::enqueue_kernel(cl::Kernel <span class="keyword">const</span>&amp; kern,</div><div class="line">                                          cl::NDRange <span class="keyword">const</span>&amp; global,</div><div class="line">                                          cl::NDRange <span class="keyword">const</span>&amp; local,</div><div class="line">                                          <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;event_impl::ptr&gt; <span class="keyword">const</span>&amp; deps) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;cl::Event&gt; dep_events;</div><div class="line">    <span class="keyword">auto</span> dep_events_ptr = &amp;dep_events;</div><div class="line">    <span class="keyword">if</span> (!context()-&gt;get_configuration().host_out_of_order) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; dep : deps)</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span> ocl_ev = <span class="keyword">dynamic_cast</span>&lt;base_event*&gt;(dep.get()))</div><div class="line">                dep_events.push_back(ocl_ev-&gt;get());</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        dep_events_ptr = <span class="literal">nullptr</span>;</div><div class="line"></div><div class="line">        sync_events(deps);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    cl::Event ret_ev;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!context()-&gt;get_configuration().host_out_of_order || _output_event ||</div><div class="line">            context()-&gt;get_configuration().enable_profiling) &#123;</div><div class="line">            _command_queue.enqueueNDRangeKernel(kern, cl::NullRange, global, local, dep_events_ptr, &amp;ret_ev);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            _command_queue.enqueueNDRangeKernel(kern, cl::NullRange, global, local, dep_events_ptr, <span class="literal">nullptr</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (cl::Error <span class="keyword">const</span>&amp; err) &#123;</div><div class="line">        <span class="keyword">throw</span> ocl_error(err);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> _events_pool-&gt;get_from_base_pool(context(), ret_ev, ++_queue_counter);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> gpu_queue::sync_events(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;event_impl::ptr&gt; <span class="keyword">const</span>&amp; deps) &#123;</div><div class="line">    <span class="keyword">bool</span> needs_barrier = <span class="literal">false</span>;</div><div class="line">    ......</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (needs_barrier) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (_output_event)</div><div class="line">                _command_queue.enqueueBarrierWithWaitList(<span class="literal">nullptr</span>, &amp;_last_barrier_ev);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                _command_queue.enqueueBarrierWithWaitList(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (cl::Error <span class="keyword">const</span>&amp; err) &#123;</div><div class="line">            <span class="keyword">throw</span> ocl_error(err);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        _last_barrier = ++_queue_counter;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/Cycles in Blender/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/22/Cycles in Blender/" itemprop="url">Cycles in Blender</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-22T19:02:32+09:00">
                2020-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2020/02/22/Cycles in Blender/" class="leancloud_visitors" data-flag-title="Cycles in Blender">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Blender简介"><a href="#0x1-Blender简介" class="headerlink" title="0x1 Blender简介"></a>0x1 Blender简介</h1><p>   Blender是一款开源的跨平台全能三维动画制作软件，提供从建模、动画、材质、渲染、到音频处理、视频剪辑等一系列动画短片制作解决方案。Blender的代码大体架构如下。<br>   <img src="/2020/02/22/Cycles in Blender/architecture.png" alt=""></p>
<p>   如图所示，Blender内置了基于物理渲染的光线追踪渲染器Cycles， Cycles除了实现CPU处理以外，还提供了OpenCL和CUDA的GPU加速，可以大幅度提升渲染速度。<br>   Cycles具有如下特点。Pach-Tracer渲染算法，多核CPU加速渲染，CUDA和OpenCL的GPU渲染支持，多GPU支持，CPU与GPU 混合加速渲染内核。</p>
<p>   除了Cycles以外，Blender从2.8版本开始还提供了EEVEE渲染引擎，EEVEE同样是基于物理渲染的光线追踪渲染器，其目标是提升渲染速度，因为目前Cycles的渲染速度还是比较慢的。<br>   本文会对Blender中Cycles的执行流程做进行分析，后续也会对EEVEE的执行流程做介绍。</p>
<h1 id="0x2-Cycles中的线程模型"><a href="#0x2-Cycles中的线程模型" class="headerlink" title="0x2 Cycles中的线程模型"></a>0x2 Cycles中的线程模型</h1><p>   Cycles中的线程模型如下所示。<br>   <img src="/2020/02/22/Cycles in Blender/thread_model.png" alt=""><br>   Cycles启动以后会创建Session线程，Session会创建一个线程池，这个线程池中的线程数量是cpu的核数。只要有需要并行处理的任务就push到线程池中的queue中，然后空闲线程从queue中取得需要处理的任务并执行。<br>   上图中左边的线程是Session线程，中间的线程TaskScheduler是线程池中其中一个线程的执行过程，线程池中其他线程的执行流程类似。<br>   上图最右边最上边的框中列出了创建线程池中线程的代码。中间的框列出了线程池中的空闲线程从队列中取出任务的过程。下面的框列出了如何把任务push到线程池的代码，注意这些push操作可以在Session中执行，也可以在线程池中的线程运行过程中执行。</p>
<h1 id="0x3-创建Session"><a href="#0x3-创建Session" class="headerlink" title="0x3 创建Session"></a>0x3 创建Session</h1><p>   创建Session的流程图如下所示。<br>   <img src="/2020/02/22/Cycles in Blender/start session.svg" alt=""><br>   这个过程主要是构建Scene Graph的过程，Scene Graph的结构体定义如下，其中可以看到需要渲染的数据都保存在这个结构体中，包括Camera，Film，Shader，Mesh，Light，Integrator等。</p>
<p>   其中的sync_data过程可以理解成把数据从Blender的上层模块设置到Cycles渲染器中。这样Cycles执行光线跟踪的时候就可以用到这些设置。</p>
<p>   数据设置好了以后就可以开始render过程，这个过程是采用光线跟踪的方式渲染出图像。<br>   这个过程中需要关注的是ShaderManager, ShaderManager管理着ShaderGraph，ShaderGraph管理着Node，并且把多个Node连接起来，组成特定操作的Pipeline.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scene</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">/* Optional name. Is used for logging and reporting. */</span></div><div class="line">  <span class="built_in">string</span> name;</div><div class="line"></div><div class="line">  <span class="comment">/* data */</span></div><div class="line">  Camera *camera;</div><div class="line">  Camera *dicing_camera;</div><div class="line">  LookupTables *lookup_tables;</div><div class="line">  Film *film;</div><div class="line">  Background *background;</div><div class="line">  Integrator *integrator;</div><div class="line"></div><div class="line">  <span class="comment">/* data lists */</span></div><div class="line">  <span class="built_in">vector</span>&lt;Object *&gt; objects;</div><div class="line">  <span class="built_in">vector</span>&lt;Mesh *&gt; meshes;</div><div class="line">  <span class="built_in">vector</span>&lt;Shader *&gt; shaders;</div><div class="line">  <span class="built_in">vector</span>&lt;Light *&gt; lights;</div><div class="line">  <span class="built_in">vector</span>&lt;ParticleSystem *&gt; particle_systems;</div><div class="line"></div><div class="line">  <span class="comment">/* data managers */</span></div><div class="line">  ImageManager *image_manager;</div><div class="line">  LightManager *light_manager;</div><div class="line">  ShaderManager *shader_manager;</div><div class="line">  MeshManager *mesh_manager;</div><div class="line">  ObjectManager *object_manager;</div><div class="line">  ParticleSystemManager *particle_system_manager;</div><div class="line">  CurveSystemManager *curve_system_manager;</div><div class="line">  BakeManager *bake_manager;</div><div class="line"></div><div class="line">  <span class="comment">/* default shaders */</span></div><div class="line">  Shader *default_surface;</div><div class="line">  Shader *default_light;</div><div class="line">  Shader *default_background;</div><div class="line">  Shader *default_empty;</div><div class="line"></div><div class="line">  <span class="comment">/* device */</span></div><div class="line">  Device *device;</div><div class="line">  DeviceScene dscene;</div><div class="line"></div><div class="line">  <span class="comment">/* parameters */</span></div><div class="line">  SceneParams params;</div><div class="line"></div><div class="line">  <span class="comment">/* mutex must be locked manually by callers */</span></div><div class="line">  thread_mutex mutex;</div><div class="line">  ......</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="0x4-光线跟踪的执行"><a href="#0x4-光线跟踪的执行" class="headerlink" title="0x4 光线跟踪的执行"></a>0x4 光线跟踪的执行</h1><p>   光线跟踪的执行流程如下所示。<br>   <img src="/2020/02/22/Cycles in Blender/path render.svg" alt=""><br>   这个过程是一个典型的光线跟踪渲染过程，先构建BVH结构体用于后续的加速，然后把一幅图像划分成tile的形式进行渲染，每个线程只处理一个tile，当然每一个位置还需要根据设置的sample的数量进行多次处理，最后根据多次处理的结果生成每一个位置对应的最后的像素值。<br>   这里的svm指的是shader virtual machine, svm对shader的执行进行了抽象，把shader中的操作提练成一个个op的形式，通过对op执行的模拟来执行shader，这些op可以理解成是shader的IR(Intermediate Representation).</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/12/The lifecycle of opt_gemm in tvm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/12/The lifecycle of opt_gemm in tvm/" itemprop="url">The lifecycle of opt_gemm in tvm</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-12T20:00:10+09:00">
                2020-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2020/01/12/The lifecycle of opt_gemm in tvm/" class="leancloud_visitors" data-flag-title="The lifecycle of opt_gemm in tvm">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x0-简介"><a href="#0x0-简介" class="headerlink" title="0x0 简介"></a>0x0 简介</h1><p>TVM是目前比较热门的深度学习编译框架，本文对tvm的函数注册机制和执行机制进行介绍，这些函数作为在python和c++代码之间交互的接口，可以理解成python和c++之间有统一的command交互接口。理解了这个交互接口，对理解tvm从python到c++的完整执行流程有很大的帮助。<br>另外本文后面以opt_gemm.py为例子，对tvm的从python到c++的执行流程进行了分析。</p>
<h1 id="0x1-函数注册"><a href="#0x1-函数注册" class="headerlink" title="0x1 函数注册"></a>0x1 函数注册</h1><p>TVM中所有上下层交互函数都封装到PackedFunc中，并且所有函数都保存在下面所示的Manager中，每一个函数都封装在Registry中，通过string作为key可以找到注册的函数并调用。tvm中使用的函数为什么要这样设计呢？好处是可以从python调用到这些函数的时候可以用统一的接口，简化接口层代码的编写，只需要把函数名作为key从Manager中找到对应的函数并调用。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// fmap以函数名称为key，保存函数列表</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Registry</span>:</span>:Manager &#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Registry*&gt; fmap;</div><div class="line">  <span class="comment">// mutex</span></div><div class="line">  <span class="built_in">std</span>::mutex mutex;</div><div class="line"></div><div class="line">  Manager() &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Registry的定义如下，Registry提供接口把函数都封装到PackedFunc类型的变量中，后面会详细介绍这些接口。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Registry &#123;</div><div class="line"> public:</div><div class="line">  Registry&amp; set_body(PackedFunc::FType f) &#123;  // NOLINT(*)</div><div class="line">    return set_body(PackedFunc(f));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  template&lt;typename FLambda&gt;</div><div class="line">  Registry&amp; set_body_typed(FLambda f) &#123;</div><div class="line">    using FType = typename detail::function_signature&lt;FLambda&gt;::FType;</div><div class="line">    return set_body(TypedPackedFunc&lt;FType&gt;(std::move(f)).packed());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  template&lt;typename T, typename R, typename ...Args&gt;</div><div class="line">  Registry&amp; set_body_method(R (T::*f)(Args...) const) &#123;</div><div class="line">    auto fwrap = [f](const T target, Args... params) -&gt; R &#123;</div><div class="line">      // call method pointer</div><div class="line">      return (target.*f)(params...);</div><div class="line">    &#125;;</div><div class="line">    return set_body(TypedPackedFunc&lt;R(const T, Args...)&gt;(fwrap));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  template&lt;typename TObjectRef, typename TNode, typename R, typename ...Args,</div><div class="line">    typename = typename std::enable_if&lt;std::is_base_of&lt;ObjectRef, TObjectRef&gt;::value&gt;::type&gt;</div><div class="line">  Registry&amp; set_body_method(R (TNode::*f)(Args...)) &#123;</div><div class="line">    auto fwrap = [f](TObjectRef ref, Args... params) &#123;</div><div class="line">      TNode* target = ref.operator-&gt;();</div><div class="line">      // call method pointer</div><div class="line">      return (target-&gt;*f)(params...);</div><div class="line">    &#125;;</div><div class="line">    return set_body(TypedPackedFunc&lt;R(TObjectRef, Args...)&gt;(fwrap));</div><div class="line">  &#125;</div><div class="line">protected:</div><div class="line">  /*! \brief name of the function */</div><div class="line">  std::string name_;</div><div class="line">  /*! \brief internal packed function */</div><div class="line">  PackedFunc func_;</div><div class="line">  friend struct Manager;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>PackedFunc的定义如下。<br>PackedFunc内部使用std::function来保存函数对象。<br>TVMArgs提供了对函数参数的封装，可以包括多个参数。<br>TVMRetValue提供了对函数返回值的封装。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">/*!</div><div class="line"> * \brief Packed function is a type-erased function.</div><div class="line"> *  The arguments are passed by packed format.</div><div class="line"> *</div><div class="line"> *  This is an useful unified interface to call generated functions,</div><div class="line"> *  It is the unified function function type of TVM.</div><div class="line"> *  It corresponds to TVMFunctionHandle in C runtime API.</div><div class="line"> */</div><div class="line">class PackedFunc &#123;</div><div class="line"> public:</div><div class="line">   /*!</div><div class="line">   * \brief The internal std::function</div><div class="line">   * \param args The arguments to the function.</div><div class="line">   * \param rv The return value.</div><div class="line">   */</div><div class="line">  using FType = std::function&lt;void (TVMArgs args, TVMRetValue* rv)&gt;;</div><div class="line">  /*! \brief default constructor */</div><div class="line">  PackedFunc() &#123;&#125;</div><div class="line">  /*! \brief constructor from null */</div><div class="line">  PackedFunc(std::nullptr_t null) &#123;&#125;  // NOLINT(*)</div><div class="line">  /*!</div><div class="line">   * \brief constructing a packed function from a std::function.</div><div class="line">   * \param body the internal container of packed function.</div><div class="line">   */</div><div class="line">  explicit PackedFunc(FType body) : body_(body) &#123;&#125;</div><div class="line"></div><div class="line"> private:</div><div class="line">  /*! \brief internal container of packed function */</div><div class="line">  FType body_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>PackedFunc中的函数参数TVMArgs定义如下，可以支持可变长度的函数参数。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line"> * \brief Union type of values</div><div class="line"> *  being passed through API and function calls.</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</div><div class="line">  <span class="keyword">int64_t</span> v_int64;</div><div class="line">  <span class="keyword">double</span> v_float64;</div><div class="line">  <span class="keyword">void</span>* v_handle;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* v_str;</div><div class="line">  TVMType v_type;</div><div class="line">  TVMContext v_ctx;</div><div class="line">&#125; TVMValue;</div><div class="line"></div><div class="line"><span class="comment">/*! \brief Arguments into TVM functions. */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TVMArgs</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">const</span> TVMValue* values;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span>* type_codes;</div><div class="line">  <span class="keyword">int</span> num_args;</div></pre></td></tr></table></figure></p>
<p>下面来分析在tvm中注册执行函数的具体执行流程，包括三种方式。</p>
<h2 id="0x11-通过set-body-typed的注册"><a href="#0x11-通过set-body-typed的注册" class="headerlink" title="0x11 通过set_body_typed的注册"></a>0x11 通过set_body_typed的注册</h2><p>下图说明了通过set_body_typed来注册函数对象到Registry::Manager的详细过程。<br><img src="/2020/01/12/The lifecycle of opt_gemm in tvm/set_body_typed.png" alt=""></p>
<p>下面是set_body_typed注册函数对象的举例说明。<br>relay模块中通过set_body_typed的注册方式来注册函数_make.relu。<br>注意这个函数内部还通过Op::Get()来得到op operator，这个op operator的管理在本文0x14小节中介绍。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\relay\op\nn\nn.cc</span></div><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"relay.op.nn._make.relu"</span>)</div><div class="line">.set_body_typed([](Expr data) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> Op&amp; op = Op::Get(<span class="string">"nn.relu"</span>);</div><div class="line">    <span class="keyword">return</span> CallNode::make(op, &#123;data&#125;, Attrs(), &#123;&#125;);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<p>relay模块依赖于topi层的实现，topi层中对relu的定义如下。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// topi\include\topi\nn.h</div><div class="line">template &lt;typename T&gt;</div><div class="line">inline tvm::Tensor relu(const tvm::Tensor&amp; t,</div><div class="line">                        T threshold = static_cast&lt;T&gt;(0),</div><div class="line">                        std::string name = "T_relu",</div><div class="line">                        std::string tag = kElementWise) &#123;</div><div class="line">  return tvm::compute(</div><div class="line">      t-&gt;shape,</div><div class="line">      [&amp;](const tvm::Array&lt;tvm::Var&gt;&amp; i) &#123;</div><div class="line">        auto threshold_const = tvm::make_const(t-&gt;dtype, threshold);</div><div class="line">        return tvm::max(t(i), threshold_const);</div><div class="line">      &#125;,</div><div class="line">      name,</div><div class="line">      tag);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后调用到lang模块中实现的tvm::max，构造出相应的TVM IR。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\lang\expr_operator.cc</span></div><div class="line"><span class="function">Expr <span class="title">max</span><span class="params">(Expr a, Expr b)</span> </span>&#123;</div><div class="line">  <span class="comment">// inf-aware simplificaiton</span></div><div class="line">  <span class="keyword">using</span> arith::is_pos_inf;</div><div class="line">  <span class="keyword">using</span> arith::is_neg_inf;</div><div class="line">  <span class="keyword">if</span> (is_pos_inf(a)) <span class="keyword">return</span> a;</div><div class="line">  <span class="keyword">if</span> (is_neg_inf(a)) <span class="keyword">return</span> b;</div><div class="line">  <span class="keyword">if</span> (is_pos_inf(b)) <span class="keyword">return</span> b;</div><div class="line">  <span class="keyword">if</span> (is_neg_inf(b)) <span class="keyword">return</span> a;</div><div class="line">  BinaryOpMatchTypes(a, b);</div><div class="line">  Expr ret = arith::TryConstFold&lt;ir::Max&gt;(a, b);</div><div class="line">  <span class="keyword">if</span> (ret.defined()) <span class="keyword">return</span> ret;</div><div class="line">  <span class="keyword">return</span> ir::Max::make(a, b);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后python模块中的relay层对relu的实现提供了python封装。这样python就可以调用到前面介绍的C++模块中的对应实现。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// python\tvm\relay\op\nn\nn.py</div><div class="line">def relu(data):</div><div class="line">    """Rectified linear unit.</div><div class="line">    return _make.relu(data)</div></pre></td></tr></table></figure></p>
<h2 id="0x12-通过set-body-method的注册"><a href="#0x12-通过set-body-method的注册" class="headerlink" title="0x12 通过set_body_method的注册"></a>0x12 通过set_body_method的注册</h2><p>下图说明了通过set_body_method来注册函数对象到Registry::Manager的详细过程。<br><img src="/2020/01/12/The lifecycle of opt_gemm in tvm/set_body_method.png" alt=""><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">下面是一个set_body_method的调用示例。</div><div class="line"><span class="comment">// src\api\api_lang.cc</span></div><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"_BijectiveLayoutBackwardShape"</span>)</div><div class="line">.set_body_method(&amp;BijectiveLayout::BackwardShape);</div></pre></td></tr></table></figure></p>
<h2 id="0x13-通过set-body的注册"><a href="#0x13-通过set-body的注册" class="headerlink" title="0x13 通过set_body的注册"></a>0x13 通过set_body的注册</h2><p>下图说明了通过set_body来注册函数对象到Registry::Manager的详细过程。<br><img src="/2020/01/12/The lifecycle of opt_gemm in tvm/set_body.png" alt=""></p>
<p>下面是一个set_body的调用示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"device_api.opencl"</span>)</div><div class="line">.set_body([](TVMArgs args, TVMRetValue* rv) &#123;</div><div class="line">    DeviceAPI* ptr = OpenCLWorkspace::Global().get();</div><div class="line">    *rv = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(ptr);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<h2 id="0x14-Relay-OP注册"><a href="#0x14-Relay-OP注册" class="headerlink" title="0x14 Relay OP注册"></a>0x14 Relay OP注册</h2><p>Relay OP保存在另外一个OpManager中，和前面的函数注册不是一个地方，这是因为这个OpManager管理的是relay operator函数，这些函数不会直接从python中调用过来。</p>
<p>OpManager的相关代码如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\relay\ir\op.cc</span></div><div class="line">::dmlc::Registry&lt;OpRegistry&gt;* OpRegistry::Registry() &#123;</div><div class="line">  <span class="keyword">return</span> ::dmlc::Registry&lt;OpRegistry&gt;::Get();</div><div class="line">&#125;</div><div class="line"><span class="comment">// single manager of operator information.</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OpManager</span> &#123;</span></div><div class="line">  <span class="comment">// mutex to avoid registration from multiple threads.</span></div><div class="line">  <span class="built_in">std</span>::mutex mutex;</div><div class="line">  <span class="comment">// global operator counter</span></div><div class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; op_counter&#123;<span class="number">0</span>&#125;;</div><div class="line">  <span class="comment">// storage of additional attribute table.</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;GenericOpMap&gt;&gt; attr;</div><div class="line">  <span class="comment">// frontend functions</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;PackedFunc*&gt; frontend_funcs;</div><div class="line">  <span class="comment">// get singleton of the op manager</span></div><div class="line">  <span class="function"><span class="keyword">static</span> OpManager* <span class="title">Global</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> OpManager* inst = <span class="keyword">new</span> OpManager();</div><div class="line">    <span class="keyword">return</span> inst;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// find operator by name</span></div><div class="line"><span class="keyword">const</span> Op&amp; Op::Get(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name) &#123;</div><div class="line">  <span class="keyword">const</span> OpRegistry* reg = dmlc::Registry&lt;OpRegistry&gt;::Find(name);</div><div class="line">  CHECK(reg != <span class="literal">nullptr</span>) &lt;&lt; <span class="string">"Operator "</span> &lt;&lt; name &lt;&lt; <span class="string">" is not registered"</span>;</div><div class="line">  <span class="keyword">return</span> reg-&gt;op();</div><div class="line">&#125;</div><div class="line"></div><div class="line">OpRegistry::OpRegistry() &#123;</div><div class="line">  OpManager* mgr = OpManager::Global();</div><div class="line">  ObjectPtr&lt;OpNode&gt; n = make_object&lt;OpNode&gt;();</div><div class="line">  n-&gt;index_ = mgr-&gt;op_counter++;</div><div class="line">  op_ = Op(n);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> EntryType&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Registry</span> &#123;</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是调用OpManager来注册op函数的代码示例。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RELAY_REGISTER_OP(<span class="string">"argsort"</span>)</div><div class="line">.describe(<span class="string">R"doc(Returns the indices that would sort an</span></div><div class="line">input array along the given axis.</div><div class="line">)doc" TVM_ADD_FILELINE)</div><div class="line">.set_num_inputs(<span class="number">1</span>)</div><div class="line">.set_attrs_type&lt;ArgsortAttrs&gt;()</div><div class="line">.add_argument(<span class="string">"data"</span>, <span class="string">"Tensor"</span>, <span class="string">"Input data."</span>)</div><div class="line">.set_support_level(<span class="number">6</span>)</div><div class="line">.add_type_rel(<span class="string">"Argsort"</span>, ArgsortRel);</div></pre></td></tr></table></figure></p>
<p>如何取得OpManager中注册的op函数呢？答案是像下面这段代码所示通过调用Op::Get()来得到。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Cache the operators that are checked </span></div><div class="line"><span class="comment">// recursively to reduce lookup overhead.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; expand_dims_op = Op::Get(<span class="string">"expand_dims"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; reshape_op = Op::Get(<span class="string">"reshape"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; transpose_op = Op::Get(<span class="string">"transpose"</span>);</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span>&amp; squeeze_op = Op::Get(<span class="string">"squeeze"</span>);</div></pre></td></tr></table></figure></p>
<h1 id="0x2-执行流程介绍"><a href="#0x2-执行流程介绍" class="headerlink" title="0x2 执行流程介绍"></a>0x2 执行流程介绍</h1><p>前面介绍了执行函数是如何注册的，那这些函数是怎样被python调用到的呢？下面来介绍一下。<br>我们知道从python调用过来的接口定义在c_runtime_api.h头文件中，这其中比较重要的是这两个API，TVMFuncCall()和TVMArrayAlloc，从API的名称上可知，TVMFuncCall对应于从python来的函数调用，TVMArrayAlloc对应于数组的分配。<br>这两个API接口定义如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// tvm\include\tvm\runtime\c_runtime_api.h</span></div><div class="line"></div><div class="line"><span class="function">TVM_DLL <span class="keyword">int</span> <span class="title">TVMFuncCall</span><span class="params">(TVMFunctionHandle func,</span></span></div><div class="line">                        TVMValue* arg_values,</div><div class="line">                        <span class="keyword">int</span>* type_codes,</div><div class="line">                        <span class="keyword">int</span> num_args,</div><div class="line">                        TVMValue* ret_val,</div><div class="line">                        <span class="keyword">int</span>* ret_type_code);</div><div class="line"></div><div class="line"><span class="function">TVM_DLL <span class="keyword">int</span> <span class="title">TVMArrayAlloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">tvm_index_t</span>* shape,</span></span></div><div class="line">                          <span class="keyword">int</span> ndim,</div><div class="line">                          <span class="keyword">int</span> dtype_code,</div><div class="line">                          <span class="keyword">int</span> dtype_bits,</div><div class="line">                          <span class="keyword">int</span> dtype_lanes,</div><div class="line">                          <span class="keyword">int</span> device_type,</div><div class="line">                          <span class="keyword">int</span> device_id,</div><div class="line">                          TVMArrayHandle* out);</div></pre></td></tr></table></figure></p>
<p>然而python是如何知道前面的函数Manager中包括了哪些函数呢？这个时候Manager提供了一个函数供上层来调用得到所有注册函数名称列表，这个函数的定义如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TVMFuncListGlobalNames</span><span class="params">(<span class="keyword">int</span> *out_size,</span></span></div><div class="line">                           <span class="keyword">const</span> <span class="keyword">char</span>*** out_array) &#123;</div><div class="line">  API_BEGIN();</div><div class="line">  TVMFuncThreadLocalEntry *ret = TVMFuncThreadLocalStore::Get();</div><div class="line">  ret-&gt;ret_vec_str = tvm::runtime::Registry::ListNames();</div><div class="line">  ret-&gt;ret_vec_charp.clear();</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; ret-&gt;ret_vec_str.size(); ++i) &#123;</div><div class="line">    ret-&gt;ret_vec_charp.push_back(ret-&gt;ret_vec_str[i].c_str());</div><div class="line">  &#125;</div><div class="line">  *out_array = dmlc::BeginPtr(ret-&gt;ret_vec_charp);</div><div class="line">  *out_size = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(ret-&gt;ret_vec_str.size());</div><div class="line">  API_END();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后python层根据前面的函数名称列表，通过下面的函数来得到每一个函数名称所对应的函数对象，python层拿到了这些函数对象以后，会在python层也创建相应的函数对象。这样python和c++层的函数操作就可以对应起来了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TVMFuncGetGlobal</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, TVMFunctionHandle* out)</span> </span>&#123;</div><div class="line">  API_BEGIN();</div><div class="line">  <span class="keyword">const</span> tvm::runtime::PackedFunc* fp =</div><div class="line">      tvm::runtime::Registry::Get(name);</div><div class="line">  <span class="keyword">if</span> (fp != <span class="literal">nullptr</span>) &#123;</div><div class="line">    *out = <span class="keyword">new</span> tvm::runtime::PackedFunc(*fp);  <span class="comment">// NOLINT(*)</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    *out = <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line">  API_END();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在python中创建函数对象的代码如下，先根据函数TVMFuncGetGlobal()来查找底层的函数对象，找到以后根据返回的handle创建上层函数对象Function。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def get_global_func(name, allow_missing=False):</div><div class="line">    handle = FunctionHandle()</div><div class="line">    check_call(_LIB.TVMFuncGetGlobal(c_str(name), ctypes.byref(handle)))</div><div class="line">    if handle.value:</div><div class="line">        return Function(handle, False)</div><div class="line"></div><div class="line">    if allow_missing:</div><div class="line">        return None</div><div class="line"></div><div class="line">    raise ValueError("Cannot find global function %s" % name)</div></pre></td></tr></table></figure></p>
<p>下面来介绍一下函数调用是如何从python层调用到C++层的，其中核心是要理解TVMFuncCall的调用过程。</p>
<h2 id="0x21-TVMFuncCall的调用过程"><a href="#0x21-TVMFuncCall的调用过程" class="headerlink" title="0x21 TVMFuncCall的调用过程"></a>0x21 TVMFuncCall的调用过程</h2><p>Python中调用TVMFuncCall的代码如下所示，其中包括了函数参数的封装。<br>self.handle是python中持有的C++ PackedFunc对象。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">class FunctionBase(object):</div><div class="line">    def __call__(self, *args):</div><div class="line"></div><div class="line">        temp_args = []</div><div class="line">        values, tcodes, num_args = _make_tvm_args(args, temp_args)</div><div class="line">        ret_val = TVMValue()</div><div class="line">        ret_tcode = ctypes.c_int()</div><div class="line">        if _LIB.TVMFuncCall(</div><div class="line">                self.handle, values, tcodes, ctypes.c_int(num_args),</div><div class="line">                ctypes.byref(ret_val), ctypes.byref(ret_tcode)) != 0:</div><div class="line">            raise get_last_ffi_error()</div><div class="line">        _ = temp_args</div><div class="line">        _ = args</div><div class="line">        return RETURN_SWITCH[ret_tcode.value](ret_val)</div></pre></td></tr></table></figure></p>
<p>从Python代码调用到C++代码的入口函数如下。<br>函数参数func是封装好的PackedFunc对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\runtime\c_runtime_api.cc</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">TVMFuncCall</span><span class="params">(TVMFunctionHandle func,</span></span></div><div class="line">                TVMValue* args,</div><div class="line">                <span class="keyword">int</span>* arg_type_codes,</div><div class="line">                <span class="keyword">int</span> num_args,</div><div class="line">                TVMValue* ret_val,</div><div class="line">                <span class="keyword">int</span>* ret_type_code) &#123;</div><div class="line">  API_BEGIN();</div><div class="line">  TVMRetValue rv;</div><div class="line">  (*<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> PackedFunc*&gt;(func)).CallPacked(</div><div class="line">      TVMArgs(args, arg_type_codes, num_args), &amp;rv);</div><div class="line">  <span class="comment">// handle return string.</span></div><div class="line">  <span class="keyword">if</span> (rv.type_code() == kStr ||</div><div class="line">      rv.type_code() == kTVMType ||</div><div class="line">      rv.type_code() == kBytes) &#123;</div><div class="line">    TVMRuntimeEntry* e = TVMAPIRuntimeStore::Get();</div><div class="line">    <span class="keyword">if</span> (rv.type_code() != kTVMType) &#123;</div><div class="line">      e-&gt;ret_str = *rv.ptr&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      e-&gt;ret_str = rv.<span class="keyword">operator</span> <span class="built_in">std</span>::<span class="built_in">string</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (rv.type_code() == kBytes) &#123;</div><div class="line">      e-&gt;ret_bytes.data = e-&gt;ret_str.c_str();</div><div class="line">      e-&gt;ret_bytes.size = e-&gt;ret_str.length();</div><div class="line">      *ret_type_code = kBytes;</div><div class="line">      ret_val-&gt;v_handle = &amp;(e-&gt;ret_bytes);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      *ret_type_code = kStr;</div><div class="line">      ret_val-&gt;v_str = e-&gt;ret_str.c_str();</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    rv.MoveToCHost(ret_val, ret_type_code);</div><div class="line">  &#125;</div><div class="line">  API_END();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// tvm\include\tvm\runtime\packed_func.h</span></div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> PackedFunc::CallPacked(TVMArgs args, TVMRetValue* rv) <span class="keyword">const</span> &#123;</div><div class="line">  body_(args, rv);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面执行对body_的调用，利用可变参数模板的递归展开来实现，这样就可以调用到真正的注册函数了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// include\tvm\runtime\packed_func.h</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> ...Args&gt;</div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FType&gt;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> TypedPackedFunc&lt;R(Args...)&gt;::AssignTypedLambda(FType flambda) &#123;</div><div class="line">  packed_ = PackedFunc([flambda](<span class="keyword">const</span> TVMArgs&amp; args, TVMRetValue* rv) &#123;</div><div class="line">      detail::unpack_call&lt;R, <span class="keyword">sizeof</span>...(Args)&gt;(flambda, args, rv);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">int</span> nargs, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unpack_call</span><span class="params">(<span class="keyword">const</span> F&amp; f, <span class="keyword">const</span> TVMArgs&amp; args, TVMRetValue* rv)</span> </span>&#123;</div><div class="line">  unpack_call_dispatcher&lt;R, nargs, <span class="number">0</span>, F&gt;::run(f, args, rv);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">int</span> nleft, <span class="keyword">int</span> index, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unpack_call_dispatcher</span> &#123;</span></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> F&amp; f,</span></span></div><div class="line">                  <span class="keyword">const</span> TVMArgs&amp; args_pack,</div><div class="line">                  TVMRetValue* rv,</div><div class="line">                  Args&amp;&amp;... unpacked_args) &#123;</div><div class="line">    unpack_call_dispatcher&lt;R, nleft - <span class="number">1</span>, index + <span class="number">1</span>, F&gt;</div><div class="line">        ::run(f, args_pack, rv,</div><div class="line">              <span class="built_in">std</span>::forward&lt;Args&gt;(unpacked_args)...,</div><div class="line">              args_pack[index]);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">int</span> index, <span class="keyword">typename</span> F&gt;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unpack_call_dispatcher</span>&lt;R, 0, index, F&gt; &#123;</span></div><div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</div><div class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">const</span> F&amp; f,</span></span></div><div class="line">                  <span class="keyword">const</span> TVMArgs&amp; args_pack,</div><div class="line">                  TVMRetValue* rv,</div><div class="line">                  Args&amp;&amp;... unpacked_args) &#123;</div><div class="line">    *rv = R(f(<span class="built_in">std</span>::forward&lt;Args&gt;(unpacked_args)...));</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>最后可以看到调用的是Variable::make来生成tvm IR。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\api\api_ir.cc</span></div><div class="line">TVM_REGISTER_GLOBAL(<span class="string">"_Var"</span>)</div><div class="line">.set_body_typed([](<span class="built_in">std</span>::<span class="built_in">string</span> s, DataType t) &#123;</div><div class="line">    <span class="keyword">return</span> Variable::make(t, s);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<h2 id="0x22-TVMArrayAlloc的调用过程"><a href="#0x22-TVMArrayAlloc的调用过程" class="headerlink" title="0x22 TVMArrayAlloc的调用过程"></a>0x22 TVMArrayAlloc的调用过程</h2><p>TVMArrayAlloc的调用过程比较简单，直接调用NDArray的接口来分配Array。<br>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">TVMArrayAlloc</span><span class="params">(<span class="keyword">const</span> <span class="keyword">tvm_index_t</span>* shape,</span></span></div><div class="line">                  <span class="keyword">int</span> ndim,</div><div class="line">                  <span class="keyword">int</span> dtype_code,</div><div class="line">                  <span class="keyword">int</span> dtype_bits,</div><div class="line">                  <span class="keyword">int</span> dtype_lanes,</div><div class="line">                  <span class="keyword">int</span> device_type,</div><div class="line">                  <span class="keyword">int</span> device_id,</div><div class="line">                  TVMArrayHandle* out) &#123;</div><div class="line">  API_BEGIN();</div><div class="line">  DLDataType dtype;</div><div class="line">  dtype.code = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(dtype_code);</div><div class="line">  dtype.bits = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(dtype_bits);</div><div class="line">  dtype.lanes = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;(dtype_lanes);</div><div class="line">  DLContext ctx;</div><div class="line">  ctx.device_type = <span class="keyword">static_cast</span>&lt;DLDeviceType&gt;(device_type);</div><div class="line">  ctx.device_id = device_id;</div><div class="line">  *out = NDArray::Internal::MoveToFFIHandle(</div><div class="line">      NDArray::Empty(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int64_t</span>&gt;(shape, shape + ndim), dtype, ctx));</div><div class="line">  API_END();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="0x03-opt-gemm-py执行流程分析"><a href="#0x03-opt-gemm-py执行流程分析" class="headerlink" title="0x03 opt_gemm.py执行流程分析"></a>0x03 opt_gemm.py执行流程分析</h1><p>下面来分析tvm自带的矩阵优化测试程序opt_gemm.py的执行流程。</p>
<h2 id="0x31-根据算法创建数据流图"><a href="#0x31-根据算法创建数据流图" class="headerlink" title="0x31 根据算法创建数据流图"></a>0x31 根据算法创建数据流图</h2><p>python代码如下，这部分描述了算法是两个矩阵相乘，根据矩阵的大小分配了相应的占位符placeholder,placeholder和tensorflow中的概念类似。然后调用compute()函数创建tvm IR。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">M = <span class="number">1024</span></div><div class="line">K = <span class="number">1024</span></div><div class="line">N = <span class="number">1024</span></div><div class="line"></div><div class="line">k = tvm.reduce_axis((<span class="number">0</span>, K), <span class="string">'k'</span>)</div><div class="line">A = tvm.placeholder((M, K), name=<span class="string">'A'</span>)</div><div class="line">B = tvm.placeholder((K, N), name=<span class="string">'B'</span>)</div><div class="line">C = tvm.compute(</div><div class="line">           (M, N),</div><div class="line">           lambda x, y: tvm.sum(A[x, k] * B[k, y], axis=k),</div><div class="line">           name=<span class="string">'C'</span>)</div></pre></td></tr></table></figure></p>
<p>上面算法描述对应到C++代码中，会创建相应的tvm node，这部分可以理解成是tvm的IR的生成。<br>下面的代码描述了上述python流程执行的最后创建ComputeOpNode的过程。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Operation ComputeOpNode::make(<span class="built_in">std</span>::<span class="built_in">string</span> name,</div><div class="line">                              <span class="built_in">std</span>::<span class="built_in">string</span> tag,</div><div class="line">                              Map&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ObjectRef&gt; attrs,</div><div class="line">                              Array&lt;IterVar&gt; axis,</div><div class="line">                              Array&lt;Expr&gt; body) &#123;</div><div class="line">  <span class="keyword">if</span> (!attrs.defined()) &#123;</div><div class="line">    attrs = Map&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ObjectRef&gt;();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">auto</span> n = make_object&lt;ComputeOpNode&gt;();</div><div class="line">  n-&gt;name = <span class="built_in">std</span>::move(name);</div><div class="line">  n-&gt;tag = <span class="built_in">std</span>::move(tag);</div><div class="line">  n-&gt;attrs = <span class="built_in">std</span>::move(attrs);</div><div class="line">  n-&gt;axis = <span class="built_in">std</span>::move(axis);</div><div class="line">  n-&gt;body = <span class="built_in">std</span>::move(body);</div><div class="line">  <span class="keyword">if</span> (n-&gt;body[<span class="number">0</span>]-&gt;IsInstance&lt;ir::Reduce&gt;()) &#123;</div><div class="line">    <span class="keyword">const</span> ir::Reduce* reduce = n-&gt;body[<span class="number">0</span>].as&lt;ir::Reduce&gt;();</div><div class="line">    n-&gt;reduce_axis = reduce-&gt;axis;</div><div class="line">  &#125;</div><div class="line">  VerifyComputeOp(n.get());</div><div class="line">  <span class="keyword">return</span> Operation(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x32-创建Schedule"><a href="#0x32-创建Schedule" class="headerlink" title="0x32 创建Schedule"></a>0x32 创建Schedule</h2><p>python代码如下。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s = tvm.create_schedule(C.op)</div></pre></td></tr></table></figure></p>
<p>对应的C++代码如下，这个时候会根据前面创建的tvm IR来生成reader graph，reader graph中描述了node之间的数据依赖关系。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">Schedule ScheduleNode::make(Array&lt;Operation&gt; ops) &#123;</div><div class="line">  <span class="keyword">auto</span> n = make_object&lt;ScheduleNode&gt;();</div><div class="line">  <span class="function">Schedule <span class="title">sch</span><span class="params">(n)</span></span>;</div><div class="line">  n-&gt;outputs = ops;</div><div class="line">  <span class="keyword">auto</span> g = schedule::CreateReadGraph(n-&gt;outputs);</div><div class="line">  Array&lt;Operation&gt; post_order = schedule::PostDFSOrder(n-&gt;outputs, g);</div><div class="line">  <span class="comment">// output set.</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;Operation&gt; output_set;</div><div class="line">  <span class="keyword">for</span> (Operation x : ops) &#123;</div><div class="line">    output_set.insert(x);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">for</span> (Operation op : post_order) &#123;</div><div class="line">    <span class="function">Stage <span class="title">stage</span><span class="params">(op)</span></span>;</div><div class="line">    stage-&gt;is_output = output_set.count(op) != <span class="number">0</span>;</div><div class="line">    n-&gt;stages.push_back(stage);</div><div class="line">    n-&gt;stage_map.Set(op, stage);</div><div class="line">    <span class="comment">// mark scan updates.</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">const</span> ScanOpNode* scan = op.as&lt;ScanOpNode&gt;()) &#123;</div><div class="line">      Array&lt;Tensor&gt; inputs;</div><div class="line">      <span class="keyword">for</span> (Tensor t : scan-&gt;state_placeholder) &#123;</div><div class="line">        inputs.push_back(t);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">for</span> (Tensor t : scan-&gt;inputs) &#123;</div><div class="line">        inputs.push_back(t);</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// Create the scan group.</span></div><div class="line">      Stage scan_group = sch.create_group(scan-&gt;update, inputs, <span class="literal">false</span>);</div><div class="line">      scan_group-&gt;attach_type = kScanUpdate;</div><div class="line">      scan_group-&gt;attach_stage = stage;</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; scan-&gt;update.size(); ++i) &#123;</div><div class="line">        Stage s = n-&gt;stage_map[scan-&gt;update[i]-&gt;op];</div><div class="line">        CHECK(scan_group.same_as(s-&gt;group));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sch;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x32-用TVM-Pass来处理schedule生成的graph"><a href="#0x32-用TVM-Pass来处理schedule生成的graph" class="headerlink" title="0x32 用TVM Pass来处理schedule生成的graph"></a>0x32 用TVM Pass来处理schedule生成的graph</h2><p>执行下面的测试代码以后会调用下面的语句来创建stmt。<br>func = tvm.build(s, [A, B, C], target=target, name=’mmult’)</p>
<p>其Python代码如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">def lower(sch,</div><div class="line">          args,</div><div class="line">          name="default_function",</div><div class="line">          binds=None,</div><div class="line">          simple_mode=False):</div><div class="line"> </div><div class="line">    cfg = current_build_config()</div><div class="line">    add_lower_pass = cfg.add_lower_pass if cfg.add_lower_pass else []</div><div class="line">    if cfg.dump_pass_ir:</div><div class="line">        add_lower_pass = BuildConfig._dump_ir.decorate_custompass(add_lower_pass)</div><div class="line">    lower_phase0 = [x[1] for x in add_lower_pass if x[0] == 0]</div><div class="line">    lower_phase1 = [x[1] for x in add_lower_pass if x[0] == 1]</div><div class="line">    lower_phase2 = [x[1] for x in add_lower_pass if x[0] == 2]</div><div class="line">    lower_phase3 = [x[1] for x in add_lower_pass if x[0] &gt; 2]</div><div class="line"></div><div class="line">    # Phase 0</div><div class="line">    if isinstance(sch, schedule.Schedule):</div><div class="line">        stmt = form_body(sch)</div><div class="line"></div><div class="line">    for f in lower_phase0:</div><div class="line">        stmt = f(stmt)</div><div class="line"></div><div class="line">    compact = ir_pass.VerifyCompactBuffer(stmt)</div><div class="line">    binds, arg_list = get_binds(args, compact, binds)</div><div class="line"></div><div class="line">    # Phase 1</div><div class="line">    stmt = ir_pass.RewriteForTensorCore(stmt, sch, binds)</div><div class="line">    stmt = ir_pass.StorageFlatten(stmt, binds, 64, cfg.instrument_bound_checkers)</div><div class="line">    stmt = ir_pass.CanonicalSimplify(stmt)</div><div class="line">    for f in lower_phase1:</div><div class="line">        stmt = f(stmt)</div><div class="line"></div><div class="line">    # Phase 2</div><div class="line">    if not simple_mode:</div><div class="line">        stmt = ir_pass.LoopPartition(stmt, cfg.partition_const_loop)</div><div class="line">    if cfg.disable_vectorize:</div><div class="line">        stmt = ir_pass.SkipVectorize(stmt)</div><div class="line">    else:</div><div class="line">        stmt = ir_pass.VectorizeLoop(stmt)</div><div class="line">    stmt = ir_pass.InjectVirtualThread(stmt)</div><div class="line">    stmt = ir_pass.InjectDoubleBuffer(stmt, cfg.double_buffer_split_loop)</div><div class="line">    stmt = ir_pass.StorageRewrite(stmt)</div><div class="line">    stmt = ir_pass.UnrollLoop(</div><div class="line">        stmt,</div><div class="line">        cfg.auto_unroll_max_step,</div><div class="line">        cfg.auto_unroll_max_depth,</div><div class="line">        cfg.auto_unroll_max_extent,</div><div class="line">        cfg.unroll_explicit)</div><div class="line">    for f in lower_phase2:</div><div class="line">        stmt = f(stmt)</div><div class="line"></div><div class="line">    # Phase 3</div><div class="line">    stmt = ir_pass.Simplify(stmt)</div><div class="line">    stmt = ir_pass.RemoveNoOp(stmt)</div><div class="line">    if not cfg.disable_select_rewriting:</div><div class="line">        stmt = ir_pass.RewriteUnsafeSelect(stmt)</div><div class="line">    for f in lower_phase3:</div><div class="line">        stmt = f(stmt)</div><div class="line">    # Instrument BoundCheckers</div><div class="line">    if cfg.instrument_bound_checkers:</div><div class="line">        stmt = ir_pass.InstrumentBoundCheckers(stmt)</div><div class="line">    if simple_mode:</div><div class="line">        return stmt</div><div class="line"></div><div class="line">    return ir_pass.MakeAPI(stmt, name, arg_list, 0, cfg.restricted_func)</div></pre></td></tr></table></figure></p>
<p>前面的ir_pass.xxx函数调用都会对应到C++的实现，这些pass是tvm中实现的中间流程处理操作，<br>例如前面的函数中执行的下列python代码，<br>stmt = ir_pass.RemoveNoOp(stmt)<br>其对应的C++代码如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// src\pass\remove_no_op.cc</span></div><div class="line"><span class="comment">// Mark the statment of each stage.</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoOpRemover</span> :</span> <span class="keyword">public</span> StmtMutator &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function">Stmt <span class="title">VisitStmt_</span><span class="params">(<span class="keyword">const</span> LetStmt* op)</span> final </span>&#123;</div><div class="line">    Stmt stmt = StmtMutator::VisitStmt_(op);</div><div class="line">    op = stmt.as&lt;LetStmt&gt;();</div><div class="line">    <span class="keyword">return</span> is_no_op(op-&gt;body) ? MakeEvaluate(op-&gt;value) : stmt;</div><div class="line">  &#125;</div><div class="line">  <span class="function">Stmt <span class="title">VisitStmt_</span><span class="params">(<span class="keyword">const</span> AttrStmt* op)</span> final </span>&#123;</div><div class="line">    <span class="keyword">if</span> (op-&gt;attr_key == <span class="string">"pragma_debug_skip_region"</span>) &#123;</div><div class="line">      <span class="keyword">return</span> MakeEvaluate(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    Stmt stmt = StmtMutator::VisitStmt_(op);</div><div class="line">    op = stmt.as&lt;AttrStmt&gt;();</div><div class="line">    <span class="keyword">return</span> is_no_op(op-&gt;body) ? MakeEvaluate(op-&gt;value) : stmt;</div><div class="line">  &#125;</div><div class="line">  ......</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">Stmt <span class="title">RemoveNoOp</span><span class="params">(Stmt stmt)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> NoOpRemover()(<span class="built_in">std</span>::move(stmt));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x33-把前面优化过的Pass调用LLVM-codegen来生成LLVM-IR"><a href="#0x33-把前面优化过的Pass调用LLVM-codegen来生成LLVM-IR" class="headerlink" title="0x33 把前面优化过的Pass调用LLVM codegen来生成LLVM IR"></a>0x33 把前面优化过的Pass调用LLVM codegen来生成LLVM IR</h2><p>python代码如下。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def build_module(lowered_func, target):</div><div class="line">    return _Build(lowered_func, target)</div></pre></td></tr></table></figure></p>
<p>C++代码如下，该段代码把tvm IR翻译成LLVM IR。<br>在其调用的Finish()函数中还会采用LLVM PassManager对已经生成的LLVM IR进行进一步优化。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> Array&lt;LoweredFunc&gt;&amp; funcs, <span class="built_in">std</span>::<span class="built_in">string</span> target)</span> </span>&#123;</div><div class="line">    InitializeLLVM();</div><div class="line">    tm_ = GetLLVMTargetMachine(target);</div><div class="line">    <span class="keyword">bool</span> system_lib = (target.find(<span class="string">"-system-lib"</span>) != <span class="built_in">std</span>::<span class="built_in">string</span>::npos);</div><div class="line">    CHECK_NE(funcs.size(), <span class="number">0U</span>);</div><div class="line">    ctx_ = <span class="built_in">std</span>::make_shared&lt;llvm::LLVMContext&gt;();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;CodeGenLLVM&gt; cg = CodeGenLLVM::Create(tm_.get());</div><div class="line">    entry_func_ = funcs[<span class="number">0</span>]-&gt;name;</div><div class="line">    cg-&gt;Init(funcs[<span class="number">0</span>]-&gt;name, tm_.get(), ctx_.get(), system_lib, system_lib);</div><div class="line">    <span class="keyword">for</span> (LoweredFunc f :  funcs) &#123;</div><div class="line">      cg-&gt;AddFunction(f);</div><div class="line">    &#125;</div><div class="line">    cg-&gt;AddMainFunction(funcs[<span class="number">0</span>]-&gt;name);</div><div class="line">    module_ = cg-&gt;Finish();</div><div class="line"></div><div class="line">    module_-&gt;addModuleFlag(llvm::Module::Warning, <span class="string">"tvm_target"</span>, llvm::MDString::get(*ctx_, target));</div><div class="line">    module_-&gt;addModuleFlag(llvm::Module::Override, <span class="string">"Debug Info Version"</span>,</div><div class="line">                           llvm::DEBUG_METADATA_VERSION);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (tm_-&gt;getTargetTriple().isOSDarwin()) &#123;</div><div class="line">      module_-&gt;addModuleFlag(llvm::Module::Override, <span class="string">"Dwarf Version"</span>, <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> verify_errors_storage;</div><div class="line">    llvm::<span class="function">raw_string_ostream <span class="title">verify_errors</span><span class="params">(verify_errors_storage)</span></span>;</div><div class="line">    LOG_IF(FATAL, llvm::verifyModule(*module_, &amp;verify_errors))</div><div class="line">        &lt;&lt; <span class="string">"LLVM module verification failed with the following errors: \n"</span></div><div class="line">        &lt;&lt; verify_errors.str();</div><div class="line">    target_ = target;</div><div class="line">    mptr_ = module_.get();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x34-根据LLVM-IR生成对应的机器指令"><a href="#0x34-根据LLVM-IR生成对应的机器指令" class="headerlink" title="0x34 根据LLVM IR生成对应的机器指令"></a>0x34 根据LLVM IR生成对应的机器指令</h2><p>调用了如下python代码就触发了机器指令的生成。<br>func(a, b, c)</p>
<p>func为前面返回的LLVM IR module对应的地址，a, b, c为对应的执行参数，也就是矩阵运算的输入。<br>对应到C++中的下述实现，调用LLVM模块来生成对应target的机器代码。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function">PackedFunc <span class="title">WrapPackedFunc</span><span class="params">(BackendPackedCFunc faddr,</span></span></div><div class="line">                          <span class="keyword">const</span> ObjectPtr&lt;Object&gt;&amp; sptr_to_self) &#123;</div><div class="line">  <span class="keyword">return</span> PackedFunc([faddr, sptr_to_self](TVMArgs args, TVMRetValue* rv) &#123;</div><div class="line">      <span class="keyword">int</span> ret = (*faddr)(</div><div class="line">          <span class="keyword">const_cast</span>&lt;TVMValue*&gt;(args.values),</div><div class="line">          <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(args.type_codes),</div><div class="line">          args.num_args);</div><div class="line">      CHECK_EQ(ret, <span class="number">0</span>) &lt;&lt; TVMGetLastError();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="0x35-评估执行时间"><a href="#0x35-评估执行时间" class="headerlink" title="0x35 评估执行时间"></a>0x35 评估执行时间</h2><p>python代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">evaluator = func.time_evaluator(func.entry_name, ctx, number=1)</div><div class="line">print('Baseline: %f' % evaluator(a, b, c).mean)</div></pre></td></tr></table></figure></p>
<p>c++代码如下，调用LLVM生成的机器指令来执行具体的运算。这部分还包括了把运算调用到其他机器的rpc操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">PackedFunc <span class="title">WrapTimeEvaluator</span><span class="params">(PackedFunc pf,</span></span></div><div class="line">                             TVMContext ctx,</div><div class="line">                             <span class="keyword">int</span> number,</div><div class="line">                             <span class="keyword">int</span> repeat,</div><div class="line">                             <span class="keyword">int</span> min_repeat_ms) &#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; ++i) &#123;</div><div class="line">        ......</div><div class="line">        <span class="comment">// start timing</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; ++i) &#123;</div><div class="line">          pf.CallPacked(args, &amp;temp);</div><div class="line">        &#125;</div><div class="line">        ......</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/14/Analysis of mali kernel driver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/14/Analysis of mali kernel driver/" itemprop="url">Analysis of mali kernel driver</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-14T20:18:31+09:00">
                2019-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/12/14/Analysis of mali kernel driver/" class="leancloud_visitors" data-flag-title="Analysis of mali kernel driver">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-硬件模块"><a href="#0x1-硬件模块" class="headerlink" title="0x1 硬件模块"></a>0x1 硬件模块</h1><p>分析Mali kernel driver代码，我们可以知道Mali Midgard硬件中包括下图所示的这些模块。下面简单介绍一下这些模块。</p>
<p>Shader Core指的是执行Shader的ALU单元，是可编程的运算单元。</p>
<p>Fixed Function Operator指的是Graphics Pipeline中诸如插值，光栅化等不可编程的硬件模块。</p>
<p>MMU是GPU中执行虚拟地址到物理地址转换的硬件模块。</p>
<p>Tiler指的是Tile Based Render中执行Tile划分的硬件模块。</p>
<p>Power Manager指管理GPU中各个硬件子模块的Power的硬件模块。</p>
<p>Job Executor，GPU User space driver根据应用执行的Graphics API来生成的Job，Job Executor是消费这些Job来驱动GPU硬件执行的状态机。</p>
<p>Cache，和CPU中的Cache类似，GPU中的cache也是为了提高GPU访问内存的速度与效率。<br><img src="/2019/12/14/Analysis of mali kernel driver/architecture.png" alt=""></p>
<h1 id="0x2-Power-Manager"><a href="#0x2-Power-Manager" class="headerlink" title="0x2 Power Manager"></a>0x2 Power Manager</h1><p>Mali Midgard中的Power Manager模块和SOC中的Power Manager模块关系如下图所示。<br><img src="/2019/12/14/Analysis of mali kernel driver/power_manager.png" alt=""></p>
<p>SoC中的Power Manager提供GPU硬件的Power输入。在SoC bring up阶段，经常会出现GPU不能工作的情况，这个时候需要和硬件工程师配合，检查SoC的Power输出到GPU的Power输入有没有配置好，是否没有上电，电压是否符合要求。另外经常出现的功耗问题也和GPU的Power设置相关，如suspend以后没有关闭GPU的Power，这样测量出来的功耗数据会很高。</p>
<p>如上图所示，GPU中包括三个可以独立控制Power的模块。分别是L2 cache，Shader cores和Tiler cores。<br>我们来想一下为什么要分成几个独立的Power模块呢？原因也是为了功耗的考虑。我们可以单独打开/关闭Shader cores的Power，同理对L2 cache和Tiler cores模块也是如此，这样可以根据GPU执行任务的情况灵活地控制这些模块Power的打开或者关闭。</p>
<h1 id="0x3-内存分配和释放"><a href="#0x3-内存分配和释放" class="headerlink" title="0x3  内存分配和释放"></a>0x3  内存分配和释放</h1><p>下图说明了kernel driver中分配内存的执行流程。<br>这个流程是由gpu user space driver驱动的，最后调用alloc_pages从Linux系统的内存管理模块分配出内存，分配的内存返回给user space driver以后，可以写入GPU执行过程中需要的数据，包括Job数据，顶点数据，纹理数据等，注意这些数据的写入是由CPU来完成的。当数据在user space driver都准备好了以后，就可以trigger kernel driver来执行GPU硬件工作，这个时候GPU硬件需要读取前面准备好的数据，这时需要借助GPU MMU来完成地址的转换工作，否则GPU没有办法完成数据的正确读取。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/alloc_memory.svg" alt=""></p>
<p>前面介绍了内存是如何分配的，下面解释一下分配好的内存在被gpu user space driver填充好需要的数据以后，又回到gpu kernel driver是如何执行的呢？下图说明了执行的流程。具体的gpu job相关处理会在后面的章节中介绍。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/use_memory.svg" alt=""></p>
<h1 id="0x4-GPU-MMU"><a href="#0x4-GPU-MMU" class="headerlink" title="0x4 GPU MMU"></a>0x4 GPU MMU</h1><p>前面已经提到GPU MMU用于支持GPU对非连续内存的访问。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/mmu.png" alt=""></p>
<p>GPU MMU的实现和CPU用来管理内存的MMU实现机制类似，也就是提供了虚拟地址到物理地址的转换。<br>如果GPU中没有MMU，则GPU需要访问的物理地址空间必须是连续的，这对系统的内存管理提出了很高的要求，如在Android系统中只能使用通过ion driver分配的cma buffer(当然也可以是系统启动时候预留出来的物理连续内存, 不过这种情况不常见)。处理不好的话，很大概率会出现内存不足OOM(Out of memory)的错误。</p>
<p>驱动中提供了两种mmu的实现，根据硬件平台进行选择。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (kbase_hw_has_feature(kbdev, BASE_HW_FEATURE_AARCH64_MMU))</div><div class="line">	kbdev-&gt;mmu_mode = kbase_mmu_mode_get_aarch64();</div><div class="line"><span class="keyword">else</span></div><div class="line">	kbdev-&gt;mmu_mode = kbase_mmu_mode_get_lpae();</div></pre></td></tr></table></figure></p>
<p>每一种mmu的实现都实现了下面的结构体。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * struct kbase_mmu_mode - object containing pointer to methods invoked for</div><div class="line"> *                         programming the MMU, as per the MMU mode supported</div><div class="line"> *                         by Hw.</div><div class="line"> * @update:           enable &amp; setup/configure one of the GPU address space.</div><div class="line"> * @get_as_setup:     retrieve the configuration of one of the GPU address space.</div><div class="line"> * @disable_as:       disable one of the GPU address space.</div><div class="line"> * @pte_to_phy_addr:  retrieve the physical address encoded in the page table entry.</div><div class="line"> * @ate_is_valid:     check if the pte is a valid address translation entry</div><div class="line"> *                    encoding the physical address of the actual mapped page.</div><div class="line"> * @pte_is_valid:     check if the pte is a valid entry encoding the physical</div><div class="line"> *                    address of the next lower level page table.</div><div class="line"> * @entry_set_ate:    program the pte to be a valid address translation entry to</div><div class="line"> *                    encode the physical address of the actual page being mapped.</div><div class="line"> * @entry_set_pte:    program the pte to be a valid entry to encode the physical</div><div class="line"> *                    address of the next lower level page table.</div><div class="line"> * @entry_invalidate: clear out or invalidate the pte.</div><div class="line"> * @flags:            bitmask of MMU mode flags. Refer to KBASE_MMU_MODE_ constants.</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">kbase_mmu_mode</span> <span class="title">const</span> <span class="title">lpae_mode</span> = &#123;</span></div><div class="line">	.update = mmu_update,</div><div class="line">	.get_as_setup = mmu_get_as_setup,</div><div class="line">	.disable_as = mmu_disable_as,</div><div class="line">	.pte_to_phy_addr = pte_to_phy_addr,</div><div class="line">	.ate_is_valid = ate_is_valid,</div><div class="line">	.pte_is_valid = pte_is_valid,</div><div class="line">	.entry_set_ate = entry_set_ate,</div><div class="line">	.entry_set_pte = entry_set_pte,</div><div class="line">	.entry_invalidate = entry_invalidate,</div><div class="line">	.flags = <span class="number">0</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>GPU MMU中的页表结构和CPU MMU的类似，也是采用了多级页表结构。</p>
<p>GPU MMU中page fault的处理。<br>在MMU中断处理函数中判断是否发生了page fault，如果是则需要分配新的page给GPU，并把新分配的page信息更新到MMU中。</p>
<h1 id="0x5-GPU-Cache"><a href="#0x5-GPU-Cache" class="headerlink" title="0x5 GPU Cache"></a>0x5 GPU Cache</h1><p>GPU Cache位于gpu和memory之间，用来提高内存访问速度和效率。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/cache.png" alt=""></p>
<p>这里面涉及到CPU和GPU之间的cache coherency的概念，指的是硬件平台上CPU的cache和GPU的cache是否可以同步。<br>如上图所示，CPU需要对内存中地址为addr的内存进行写操作，如果CPU采用的是write through的cache机制，CPU对内存地址addr的修改会立即写入到内存中，如果在GPU的cache中原来保存有地址addr的cache，这个时候通过Coherent Connection机制来通知GPU，告知内存地址addr对应的cache失效了，下次GPU访问内存地址addr的内存，从GPU的cache中不能读取到内存地址addr对应的数据了(cache不命中)，需要重新从内存中读取才能得到正确数据。</p>
<p>如果CPU采用的是write back的cache机制，CPU对地址addr修改以后不会立刻写回内存，这个时候可能大家觉得这样就没有办法通过到GPU了，其实还是有机制在这种情况下也是有办法来通过GPU去使对应的GPU cache失效的。这种机制叫“窥探（snooping）”协议，窥探协议的思想是，cache不仅仅在做内存传输的时候才和总线打交道，而是不停地在窥探总线上发生的数据交换，跟踪其他缓存在做什么。所以当CPU的cache代表CPU去读写内存时，GPU也会得到通知，这样CPU和GPU的缓存可以时刻保持同步。只要GPU或者CPU其中任何一方写了内存或者cache，对方马上就知道这块内存在它们自己的cache中对应的段已经失效，然后读取的时候需要从内存中读取。</p>
<p>注意在支持cache coherency的硬件平台上，上述操作是不需要软件干涉的，都是通过硬件来保证的。指ARM平台上CPU和GPU是cache coherency的。</p>
<p>但是如果CPU是x86的，GPU的mali的SoC平台中，要做到硬件的cache coherency比较困难，这个时候是需要软件来保证的。这样gpu driver的复杂度就增加了。</p>
<p>在mali 驱动中有下面三种cache coherency的设置。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> COHERENCY_ACE_LITE 0</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> COHERENCY_ACE      1</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> COHERENCY_NONE     31</span></div></pre></td></tr></table></figure></p>
<p>在驱动初始化函数kbase_device_coherency_init()中会设置cache coherency的类型。<br>如下所示，默认是设置成COHERENCY_NONE<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">kbdev-&gt;system_coherency = COHERENCY_NONE;</div></pre></td></tr></table></figure></p>
<p>也可以通过dts来配置<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">coherency_override_dts = of_get_property(kbdev-&gt;dev-&gt;of_node,</div><div class="line">                        <span class="string">"system-coherency"</span>,</div><div class="line">                        <span class="literal">NULL</span>);</div><div class="line">override_coherency = be32_to_cpup(coherency_override_dts);</div><div class="line">kbdev-&gt;system_coherency = override_coherency;</div></pre></td></tr></table></figure></p>
<p>如下代码中，在CPU更新完page directory以后，如果不是cache coherency平台，这个时候需要sync来保证cache的一致性。<br>注意这个时候page directoy是在CPU侧写入的，CPU写入有可能只是写到cache的write buffer中，并没有真正写入内存，需要通过dma_sync_single_for_device来保证cache的write buffer中的内容都<br>写入了memory，这样后续GPU访问page directoy的时候能取得正确的数据。<br>这里有一个疑问，就是如果GPU的cache中已经有了对应内存地址的缓存内容，在不是cache coherency的平台中，是如何通知到GPU，使其对应的cache失效的呢？这部分我的理解可能也是通过硬件总线来完成的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * kbase_mmu_sync_pgd - sync page directory to memory</div><div class="line"> * This should be called after each page directory update.</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kbase_mmu_sync_pgd</span><span class="params">(struct kbase_device *kbdev,</span></span></div><div class="line">		<span class="keyword">dma_addr_t</span> handle, <span class="keyword">size_t</span> size)</div><div class="line">&#123;</div><div class="line">	<span class="comment">/* If page table is not coherent then ensure the gpu can read</span></div><div class="line">	 * the pages from memory</div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (kbdev-&gt;system_coherency != COHERENCY_ACE)</div><div class="line">		dma_sync_single_for_device(kbdev-&gt;dev, handle, size,</div><div class="line">				DMA_TO_DEVICE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下代码所示，在security模式下关闭cache coherent，保证内存数据读写的安全性。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kbase_gpu_disable_coherent</span><span class="params">(struct kbase_device *kbdev)</span></span></div><div class="line">&#123;</div><div class="line">	lockdep_assert_held(&amp;kbdev-&gt;hwaccess_lock);</div><div class="line"></div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * When entering into protected mode, we must ensure that the</div><div class="line">	 * GPU is not operating in coherent mode as well. This is to</div><div class="line">	 * ensure that no protected memory can be leaked.</div><div class="line">	 */</div><div class="line">	<span class="keyword">if</span> (kbdev-&gt;system_coherency == COHERENCY_ACE)</div><div class="line">		kbase_cache_set_coherency_mode(kbdev, COHERENCY_ACE_LITE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以从下面的代码来理解一下dma_sync_single_for_cpu和dma_sync_single_for_device的区别。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kbasep_10969_workaround_clamp_coordinates</span><span class="params">(struct kbase_jd_atom *katom)</span></span></div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="comment">// DMA transfer is complete</span></div><div class="line">    copy_size = MIN(PAGE_SIZE - offset, JOB_HEADER_SIZE);</div><div class="line">    page_1 = kmap_atomic(p);</div><div class="line">    <span class="comment">/* page_1 is a u32 pointer, offset is expressed in bytes */</span></div><div class="line">    page_1 += offset&gt;&gt;<span class="number">2</span>;</div><div class="line">    kbase_sync_single_for_cpu(katom-&gt;kctx-&gt;kbdev,</div><div class="line">            kbase_dma_addr(p) + offset,</div><div class="line">            copy_size, DMA_BIDIRECTIONAL);</div><div class="line">    <span class="built_in">memcpy</span>(dst, page_1, copy_size);</div><div class="line">    ......</div><div class="line">    <span class="comment">/* Flush CPU cache to update memory for future GPU reads*/</span></div><div class="line">    <span class="built_in">memcpy</span>(page_1, dst, copy_size);</div><div class="line">    p = as_page(page_array[page_index]);</div><div class="line">    kbase_sync_single_for_device(katom-&gt;kctx-&gt;kbdev,</div><div class="line">            kbase_dma_addr(p) + offset,</div><div class="line">            copy_size, DMA_TO_DEVICE);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>kbase_sync_single_for_cpu等同于dma_sync_single_for_cpu。用于数据从GPU到内存的DMA传送刚刚完成的情况。当DMA传输完成时，GPU已经将数据传输到内存，但是cache中可能还有老数据，为了避免CPU读取还是cache中的老数据，需要调用dma_sync_single_for_cpu，在ARM平台上相当于”invalidate”操作，也就是使cache无效的操作。从上面的代码可以，DMA传输完成后，先是调用了dma_sync_single_for_cpu，CPU再从内存地址page_1中读取数据。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/dma_sync_single_for_cpu.png" alt=""></p>
<p>kbase_sync_single_for_device等同于dma_sync_single_for_device。用于数据从内存到GPU的DMA传送开始之前的情况，在CPU往内存的DMA缓冲区写入数据之后，这个时候数据可能没有立即反映到内存的DMA缓冲区上，因为该DMA缓冲区可能带有write buffer，导致数据只是写到了write buffer中，没有写入内存的DMA缓冲区上（为什么没有立即写入到内存的DMA缓冲区上呢？ 是为了等write buffer达到一定的大小以后一次写入到内存，为了提高效率）。这个时候需要调用dma_sync_single_for_device来做flush/clean操作，这样后续GPU启动DMA传输的时候可以从DMA缓冲区得到正确的数据。<br>如上代码所示，dma_sync_single_for_device之前调用了memcpy把数据传输到DMA缓冲区中，然后执行dma_sync_single_for_device()flush<br>write buffer中的数据，保证后续GPU的操作能得到正确的DMA数据。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/dma_sync_single_for_device.png" alt=""></p>
<h1 id="0x6-中断处理"><a href="#0x6-中断处理" class="headerlink" title="0x6 中断处理"></a>0x6 中断处理</h1><p>从下面代码中我们可以知道gpu kernel driver需要处理下面三种中断。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">irq_handler_t</span> kbase_handler_table[] = &#123;</div><div class="line">    [JOB_IRQ_TAG] = kbase_job_irq_handler,</div><div class="line">    [MMU_IRQ_TAG] = kbase_mmu_irq_handler,</div><div class="line">    [GPU_IRQ_TAG] = kbase_gpu_irq_handler,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下图是三种中断处理函数的执行流程。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/irq.png" alt=""></p>
<p>中断的处理流程如下。</p>
<ol>
<li>调用request_irq注册中断。</li>
<li>操作GPU register启动中断。</li>
<li>GPU硬件执行完成，触发中断。</li>
<li>处理中断处理函数，读取GPU register来判断硬件执行情况做进一步动作。</li>
</ol>
<h1 id="0x7-GPU-Job处理"><a href="#0x7-GPU-Job处理" class="headerlink" title="0x7. GPU Job处理"></a>0x7. GPU Job处理</h1><p>Mali GPU Job可以理解成GPU硬件能理解的IR(中间语言)。在Broadcom V3D中的CLE(control list executor)也是类似的概念。<br>gpu user space driver简单来说就是把上层应用的API调用转换成Job的描述。<br>kernel driver拿到这些Job以后，把Job的内存地址告诉GPU硬件，GPU硬件的Job Executor就开始parse这些Job，然后驱动GPU硬件的其他模块完成渲染或者计算工作。<br>Job可以组成Job chain的形式，Job chain中Job的执行可以有前后关系，如果该Job中需要读取texture信息，则Job中还包括texture存储位置的地址信息。</p>
<p><img src="/2019/12/14/Analysis of mali kernel driver/job.png" alt=""></p>
<p>下面的流程说明了GPU Job在kernel driver中是如何提交给GPU硬件的Job Executor的。<br><img src="/2019/12/14/Analysis of mali kernel driver/job_submit.svg" alt=""></p>
<h1 id="0x8-GPU-DVFS"><a href="#0x8-GPU-DVFS" class="headerlink" title="0x8. GPU DVFS"></a>0x8. GPU DVFS</h1><p>这部分是根据GPU的loading进行动态调整GPU的运行频率，也可以动态调整GPU Power的电压。这部分的实现依赖于Linux kernel提供的DVFS（Dynamic Voltage and Frequency Scaling）机制。<br>当然GPU dvfs的启用与否是根据场景来的。在功耗不敏感的场景下，如汽车娱乐系统中，GPU DVFS一般是关闭的。</p>
<h1 id="0x9-Reference"><a href="#0x9-Reference" class="headerlink" title="0x9 Reference"></a>0x9 Reference</h1><p><a href="https://developer.arm.com/tools-and-software/graphics-and-gaming/mali-drivers/midgard-kernel" target="_blank" rel="external">mali kernel driver source code</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/06/Use AI to speed up AV1 encoder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/06/Use AI to speed up AV1 encoder/" itemprop="url">Use AI to speed up AV1 encoder</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-06T17:00:10+09:00">
                2019-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/04/06/Use AI to speed up AV1 encoder/" class="leancloud_visitors" data-flag-title="Use AI to speed up AV1 encoder">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-AV1的编码复杂性"><a href="#0x1-AV1的编码复杂性" class="headerlink" title="0x1 AV1的编码复杂性"></a>0x1 AV1的编码复杂性</h1><p>我们知道AV1的官方参考实现是libaom，由于AV1的编码复杂度高，如果采用libaom编码器来生成AV1的码流离实时编码还有很大的距离。我们知道传统视频编码器中有宏块的概念，宏块是16x16的亮度块 + 2个 8x8的色度快。从HEVC开始，到现在的AV1进一步引入了partiton的概念，也就是树形编码的概念，也就是说把先规定好最大的编码单元，这个最大的编码单元称为super block，在HEVC一般是64x64，在AV1中为128x128。然后进行四叉树划分，AV1中直至划分成4x4，HEVC中直至划分成8x8。而且这种划分进一步扩展到预测单元和变换单元。据统计，AV1编码中的复杂度80%是因为partiton引入的，所以要是能有一个快速方法来加速partiton的判断的话，AV1的编码速度能大幅提升。</p>
<p>AV1中的partiton划分如下图所示。<br><img src="https://wenxiaoming.github.io/2019/03/02/The-overview-of-AV1-coding/partition2.png" alt=""></p>
<h1 id="0x2-AI加速partiton划分"><a href="#0x2-AI加速partiton划分" class="headerlink" title="0x2 AI加速partiton划分"></a>0x2 AI加速partiton划分</h1><pre><code>在libaom目前的实现中，AI加速主要用在intra frame的partition划分优化上。
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">av1_intra_mode_cnn_partition(</div><div class="line">    &amp;cpi-&gt;common, x, bsize, x-&gt;quad_tree_idx, &amp;partition_none_allowed,</div><div class="line">    &amp;partition_horz_allowed, &amp;partition_vert_allowed, &amp;do_rectangular_split,</div><div class="line">    &amp;do_square_split);</div></pre></td></tr></table></figure>
<p>该函数的输入是图像的像素值，可以理解为图像对应的纹理。并且需要把对应亮度/色度值转换成0~1之间的浮点数。如下代码所示，c为亮度或色度分量的index，这里c为0，为亮度分量。max_val为亮度/色度分量的最大值255(假设为8bit yuv)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height; ++i)</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; width; ++j)</div><div class="line">      input[i * in_stride + j] = (<span class="keyword">float</span>)dgd[c][i * stride + j] / max_val;</div></pre></td></tr></table></figure>
<p>输出是这几个变量partition_none_allowed，partition_horz_allowed，partition_vert_allowed，do_rectangular_split，do_square_split。用来对后续的partition的划分进行优化，从变量的名称可以看到这些变量会对后续的partition划分进行限制，也就是减少了partition的数目。</p>
<p>推理采用的网络是CNN + DNN的结合。<br>CNN是5层网络结构，网络定义如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> CNN_CONFIG av1_intra_mode_cnn_partition_cnn_config = &#123;</div><div class="line">    NUM_CNN_LAYERS,  <span class="comment">// num_layers</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// is_residue</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// ext_width</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// ext_height</span></div><div class="line">    <span class="number">0</span>,               <span class="comment">// strict_bounds</span></div><div class="line">    &#123;</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_0_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_0_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_0_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_0_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_0_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_0_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_0_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_0_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">-1</span>,                <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_1_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_1_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_1_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_1_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_1_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_1_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_1_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_1_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">3</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_2_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_2_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_2_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_2_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_2_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_2_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_2_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_2_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">2</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_3_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_3_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_3_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_3_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_3_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_3_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_3_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_3_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">1</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">        &#123;</div><div class="line">            CNN_LAYER_4_IN_CH,                                <span class="comment">// in_channels</span></div><div class="line">            CNN_LAYER_4_WIDTH,                                <span class="comment">// filter_width</span></div><div class="line">            CNN_LAYER_4_WIDTH,                                <span class="comment">// filter_height</span></div><div class="line">            CNN_LAYER_4_OUT_CH,                               <span class="comment">// out_channels</span></div><div class="line">            CNN_LAYER_4_HORZ_STRIDE,                          <span class="comment">// skip_width</span></div><div class="line">            CNN_LAYER_4_VERT_STRIDE,                          <span class="comment">// skip_height</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// maxpool</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_4_kernel,  <span class="comment">// weights</span></div><div class="line">            av1_intra_mode_cnn_partition_cnn_layer_4_bias,    <span class="comment">// bias</span></div><div class="line">            PADDING_VALID,                                    <span class="comment">// pad</span></div><div class="line">            RELU,                                             <span class="comment">// activation</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// deconvolve</span></div><div class="line">            <span class="number">0</span>,                                                <span class="comment">// branch</span></div><div class="line">            BRANCH_NO_COPY,                                   <span class="comment">// branch_copy_type</span></div><div class="line">            BRANCH_NOC,        <span class="comment">// branch_combine_type</span></div><div class="line">            NO_BRANCH_CONFIG,  <span class="comment">// branch_config</span></div><div class="line">            NO_BN_PARAMS,      <span class="comment">// bn_params</span></div><div class="line">            <span class="number">0</span>,                 <span class="comment">// output_num</span></div><div class="line">        &#125;,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>DNN是两层网络结构，网络定义如下。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> NN_CONFIG av1_intra_mode_cnn_partition_branch_0_dnn_config = &#123;</div><div class="line">    BRANCH_0_NUM_DNN_FEATURES,</div><div class="line">    BRANCH_0_NUM_LOGITS,</div><div class="line">    BRANCH_0_NUM_DNN_LAYERS,</div><div class="line">    &#123;</div><div class="line">        BRANCH_0_NUM_DNN_LAYER_0_UNITS,</div><div class="line">        BRANCH_0_NUM_DNN_LAYER_1_UNITS,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_0_kernel,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_1_kernel,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_logits_kernel,</div><div class="line">    &#125;,</div><div class="line">    &#123;</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_0_bias,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_dnn_layer_1_bias,</div><div class="line">        av1_intra_mode_cnn_partition_branch_0_logits_bias,</div><div class="line">    &#125;,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="0x3-推理模型的训练"><a href="#0x3-推理模型的训练" class="headerlink" title="0x3 推理模型的训练"></a>0x3 推理模型的训练</h1><p>以上编码过程中采用的CNN + DNN的网络是经过训练的，在libaom的代码中并没有提供这个网络结构的训练过程代码。参考<a href="https://zhuanlan.zhihu.com/p/40034222" target="_blank" rel="external">HEVC partition优化</a>可以大体知道其训练过程。应该是设计好网络以后，通过大量样本数据来训练得到该推理网络的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/30/Buffer sharing in Weston/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/30/Buffer sharing in Weston/" itemprop="url">Buffer sharing in Weston</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-30T19:30:00+09:00">
                2019-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/30/Buffer sharing in Weston/" class="leancloud_visitors" data-flag-title="Buffer sharing in Weston">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Weston简介"><a href="#0x1-Weston简介" class="headerlink" title="0x1 Weston简介"></a>0x1 Weston简介</h1><h2 id="0x11-X系统"><a href="#0x11-X系统" class="headerlink" title="0x11 X系统"></a>0x11 X系统</h2><p>X即X11、X Window System，是用于在类UNIX的操作系统上的位图显示的窗口系统，提供了GUI环境的基本框架，可以在显示设备上绘制、移动窗口，通过鼠标、键盘、触摸屏与用户交互. X Server是X显示服务的一种开源实现，其系统结构如下图所示<br><img src="/2019/03/30/Buffer sharing in Weston/x-architecture.png" alt=""></p>
<h2 id="0x12-Wayland系统"><a href="#0x12-Wayland系统" class="headerlink" title="0x12 Wayland系统"></a>0x12 Wayland系统</h2><p>Wayland是一个显示服务协议，服务端为Wayland Compositor，服务端把把X系统中的X Server和Compositor合二为一，作为类Unix操作系统上更现代、简洁的窗口系统，旨在替换X系统。Weston是Wayland Compositor的参考实现。下面是Wayland官网文档给出的架构简图.<br><img src="/2019/03/30/Buffer sharing in Weston/wayland-architecture.png" alt=""></p>
<p>Wayland协议为Client/Server模式，客户端为图形应用程序，发送绘制命令，请求在各自输出缓冲区的显示，服务器为Compositor，控制各个客户端输出缓冲区的合成和显示。</p>
<p>Wayland参考实现Weston包括两层协议。</p>
<p>一个为底层IPC协议。采用Linux Domain Socket实现的IPC，这部分采用手动写的C语言实现。</p>
<p>另一个是上层消息协议。这部分采用libffi来实现，从规定格式的XML文件中自动生成，可以灵活地动态扩展或者用于错误验证。处理客户端和Weston之间的上层交互流程，以实现窗口系统的基本功能。</p>
<p>Wayland参考实现包括两部分，libwayland-client和libwayland-server，其架构简图如下所示。<br><img src="/2019/03/30/Buffer sharing in Weston/Wayland_protocol_architecture.svg" alt=""></p>
<h1 id="0x2-Buffer管理"><a href="#0x2-Buffer管理" class="headerlink" title="0x2 Buffer管理"></a>0x2 Buffer管理</h1><p>在Weston的实现中，客户端先把内容绘制到一个buffer中，然后weston把多个客户端绘制的buffer通过compositor模块合成在一起。这里面涉及到buffer在各个模块之间的传递，从性能的角度考虑，我们很自然地想到如何避免memory copy的问题。下来我们来看一下如何实现zero memory copy的。</p>
<p>Weston中的buffer用wl_buffer对象来描述。这个buffer需要在客户端和Compositor之间共享。目前有两种buffer的管理模式。</p>
<ol>
<li>wl_shm<br>这种方式是通过共享内存的方式来实现客户端和Compositor之间的共享，通过这种方式分配的内存是物理不连续的，这种方式一般用于采用软件绘制的情况，当buffer在客户端绘制完成以后，Compositor得到通知开始合成的时候，需要通过glTexImage2D()函数把buffer作为纹理上传到GPU中，这样的话性能是会受到影响的，因为纹理上传一般是比较耗时的操作。</li>
<li><p>wl_drm<br>这种方式通过Wayland EGL中的相关机制来保证，客户端通过wayland-egl.h的相关接口EGLSurface来创建GPU的输出buffer，然后客户端开始绘制，绘制完成以后，客户端的GPU输出buffer通过eglCreateImageKHR()接口创建EGLImage，这个EGLImage可以直接作为Compositor的输入纹理来使用，不需要额外的拷贝工作。</p>
<p>开源的mesa drm实现定义了drm Wayland扩展, 这个时候客户端和Compositor之间可以共享drm (GEM) buffers。</p>
<p>下面介绍一下基于KMS BO buffer type的mesa wl_drm共享流程<br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_1.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_2.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_3.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_4.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_5.png" alt=""><br> <img src="/2019/03/30/Buffer sharing in Weston/wl_kms_6.png" alt=""></p>
</li>
</ol>
<h1 id="0x3-与Android上图形系统的比较"><a href="#0x3-与Android上图形系统的比较" class="headerlink" title="0x3 与Android上图形系统的比较"></a>0x3 与Android上图形系统的比较</h1><ol>
<li><p>Buffer的分配<br>Android上的buffer是在服务端（SurfaceFlinger）分配的，然后通过ION机制实现buffer的共享。<br>而Wayland系统中buffer是在客户端分配的，通过底层EGL驱动提供的buffer共享管理机制，再配合IPC机制实现客户端和服务端之间的buffer共享。</p>
</li>
<li><p>Window管理器的实现<br>Android上有单独的WMS(Window Manager Service)模块来做窗口管理的工作。而Wayland系统中在Weston中实现了窗口管理的工作，也就是是窗口管理和合成是在同一个进程中完成的。</p>
</li>
<li><p>Android on Wayland<br>把Android上的SurfaceFlinger作为一个Wayland Client，然后参与Weston的合成。架构图如下<br><img src="/2019/03/30/Buffer sharing in Weston/AndroidOnWayland.png" alt=""></p>
<p>上图的架构有点类似于把X Server作为一个Wayland Client，如下图所示<br><img src="/2019/03/30/Buffer sharing in Weston/xwayland.png" alt=""></p>
</li>
</ol>
<h1 id="0x4-Run-Weston-on-Ubuntu"><a href="#0x4-Run-Weston-on-Ubuntu" class="headerlink" title="0x4 Run Weston on Ubuntu"></a>0x4 Run Weston on Ubuntu</h1><p>   把Wayland protocol和Weston相关实现porting到Ubuntu上，Weston加载X11-backend，也就是说Weston作为X Server的一个Client，把Weston的合成输出在接入到Ubuntu的X Server系统中来输出。</p>
<p>   绘制和合成流程如下图所示<br>   <img src="/2019/03/30/Buffer sharing in Weston/Draw &amp; Composition.png" alt=""></p>
<p>   测试效果如下图所示<br>   <img src="/2019/03/30/Buffer sharing in Weston/demo.png" alt=""></p>
<h1 id="0x5-参考"><a href="#0x5-参考" class="headerlink" title="0x5 参考"></a>0x5 参考</h1><p><a href="https://wayland.freedesktop.org/architecture.html" target="_blank" rel="external">Wayland architecture</a><br><a href="https://events.static.linuxfound.org/sites/events/files/slides/als2015_wayland_weston_v2.pdf" target="_blank" rel="external">Wayland/Weston Renderer</a><br><a href="https://at.projects.genivi.org/wiki/display/DIRO/Android+display+subsystem+as+a+wayland+client" target="_blank" rel="external">Android display subsystem as a wayland client</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/23/How escher support physically based render/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/23/How escher support physically based render/" itemprop="url">How escher support physically based render</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-23T12:00:00+09:00">
                2019-03-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/23/How escher support physically based render/" class="leancloud_visitors" data-flag-title="How escher support physically based render">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-物理渲染和光栅化渲染"><a href="#0x1-物理渲染和光栅化渲染" class="headerlink" title="0x1 物理渲染和光栅化渲染"></a>0x1 物理渲染和光栅化渲染</h1><h2 id="0x21-传统光栅化渲染器的特点"><a href="#0x21-传统光栅化渲染器的特点" class="headerlink" title="0x21 传统光栅化渲染器的特点"></a>0x21 传统光栅化渲染器的特点</h2><p>光栅化是指把3D空间的几何图形及其色彩信息转换至2D计算机屏幕上像素的过程。光栅化渲染器的pipeline包括Vertex Shader,Rasterization,Fragment Shader等阶段，目前GPU硬件也是采用这种高效率的光栅化架构。基于这些GPU硬件设计的渲染API有Windows上的DirectX,跨平台的OpenGL和Vulkan，已经Apple的Metal等。应用程序可以基于这些渲染API开发出酷炫的3D效果。但是这种光栅化的缺点也很明显，那就是无法完全模拟真实场景下的光线传播，导致绘制效果失真。</p>
<p>下图说明了光栅化渲染器的流水线。</p>
<p><img src="/2019/03/23/How escher support physically based render/pipeline.png" alt=""></p>
<p>现代GPU中vertex shader和fragment shader一般是逻辑的概念，当时比较早的GPU是采用两种独立的硬件单元(不是Unified Shader)来实现的，如ARM Mali-400就是这种架构，这种架构的缺点是vertex shader和fragment shader的负载没办法平衡，极端情况下会出现其中一种硬件Shader满负荷运行，另外一种硬件Shader空闲的情况。后来的架构一般是基于通用可编程计算单元实现这些功能。也就是我们常说的Unified Shader架构。如树莓派中的Soc VideoCore采用了BroadCom V3D GPU, 其中的Unified Shader中采用QPU这种通用可编程计算单元来实现。</p>
<p>移动GPU相对桌面GPU的架构也有差别，因为移动平台上对带宽及功耗的要求都比较高。<br>桌面GPU一般采用IMR(Immediate Mode Rendering)架构, 这种架构需要同时对该次渲染的全部物体进行处理，需要频繁访问系统帧缓存（位于系统内存里），故对带宽要求较高。</p>
<p>移动GPU一般采用TBR架构(Tile Based Rendering)。TBR架构包括两个阶段Tiling和Binning。Tiling阶段把整个画面分成小块，然后计算每个小块中有哪些三角形需要处理。Binning阶段每次只对一个小块中包括的三角形进行处理，这种方式避免了对帧缓存（位于系统内存里）的频繁读写和修改，因为这些小块中的三角形的渲染是在GPU上的高速缓存里进行，所以能节约带宽，同时也减少了功耗。</p>
<p>Imagination在TBR架构的基础上又提出了TBDR(Tile Based Deferred Rendering), 在执行shading之前加入HSR(Hidded Surface Remove), 这个模块利用vertex shader/rasterization之后的fragment的深度值来优化掉不必要的计算。</p>
<h2 id="0x22-物理渲染器的特点"><a href="#0x22-物理渲染器的特点" class="headerlink" title="0x22 物理渲染器的特点"></a>0x22 物理渲染器的特点</h2><p>物理渲染器PBR(Physically Based Rendering),也称光线跟踪器(Ray tracer)。采用该算法渲染的结果看起来更真实，因为它基于物理参数的方法来编写材质，而且考虑了光线的发射和折射，材质对光线的吸收等。</p>
<p>光线跟踪算法描述如下，沿着到达视点的光线的反方向跟踪，经过屏幕上每一个象素，找出与视线相交的物体表面点，并继续跟踪，找出影响点光强的所有光源，从而算出点上精确的光线强度。这种算法计算量极大，一般用于离线渲染。</p>
<p>一个典型的物理渲染器包括如下模块。<br>相机<br>光线-对象相交测试<br>光照分布/光线传播<br>递归光线跟踪机制</p>
<p>考虑到PBR的计算量太大，只适合离线渲染，后来基于全局光照Global Illuslaton技术的来实现实时PBR，因为考虑到了速度的提升，在渲染质量上会有损失。</p>
<p>早期Ray tracing的硬件有德国萨尔兰大学计算机图形小组在2005年的SIGGRAPH上展示了第一个实时光线追踪加速硬件——RPU（Ray Processing Unit），最近有NVIDIA在GPU硬件中加入了Ray tracing。</p>
<p>下图是采用Blender中的cycles物理渲染器渲染的坦克效果图，如果完全用CPU来计算，速度很慢，大概需要几十分钟。<br><img src="/2019/03/23/How escher support physically based render/tank.png" alt=""></p>
<h1 id="0x2-Escher是如何做到物理渲染的？"><a href="#0x2-Escher是如何做到物理渲染的？" class="headerlink" title="0x2 Escher是如何做到物理渲染的？"></a>0x2 Escher是如何做到物理渲染的？</h1><p>Escher是Google下一代操作系统Fuchsia上内置的基于物理的真实感渲染引擎，它和Scenic一起提供了Fuchsia上的合成及进一步特效处理功能。</p>
<p>Escher目前看来主要采用光照和阴影技术来达到物理渲染的效果。</p>
<p>阴影是真实感渲染的一个重要组成部分，它对增加渲染物体的表面细节，帮助观察者增加对场景的空间感，从而更好地来判断物体的位置关系以及形状等有很大的帮助。可以说没有了阴影，3D场景中的真实感和吸引力将降低。</p>
<p>Escher中包括了如下几种阴影技术，ShadowMap、ShadowVolume等。</p>
<p>从Escher的实现代码可知，Escher还只是实现了部分物理渲染的功能，主要是通过light和shadow来体现真实感效果，后续要支持AR/VR中更多酷炫效果的话，需要进一步开发。</p>
<h1 id="0x03-展望"><a href="#0x03-展望" class="headerlink" title="0x03 展望"></a>0x03 展望</h1><p>随着GPU硬件中增加了Ray tracing的功能，主流API都增加了对Ray tracing的支持，未来Escher中可能会直接调用这些API(目前Escher中是调用了Vulkan，也就是说会调用Vulkan的Ray tracing支持)来加速Ray tracing的处理。</p>
<p>下来介绍一种主流API对 ray tracing的支持</p>
<h2 id="0x31-Directx-raytracing"><a href="#0x31-Directx-raytracing" class="headerlink" title="0x31 Directx raytracing"></a>0x31 Directx raytracing</h2><p>DirectX Raytracing在DirectX 12 API的基础上引入了下面这些概念<br><a href="https://devblogs.microsoft.com/directx/announcing-microsoft-directx-raytracing/" target="_blank" rel="external">DirectX Raytracing</a></p>
<p>What is DirectX Raytracing?<br>At the highest level, DirectX Raytracing (DXR) introduces four, new concepts to the DirectX 12 API:</p>
<p>The acceleration structure is an object that represents a full 3D environment in a format optimal for traversal by the GPU.  Represented as a two-level hierarchy, the structure affords both optimized ray traversal by the GPU, as well as efficient modification by the application for dynamic objects.</p>
<p>A new command list method, DispatchRays, which is the starting point for tracing rays into the scene.  This is how the game actually submits DXR workloads to the GPU.</p>
<p>A set of new HLSL shader types including ray-generation, closest-hit, any-hit, and miss shaders.  These specify what the DXR workload actually does computationally.  When DispatchRays is called, the ray-generation shader runs.  Using the new TraceRay intrinsic function in HLSL, the ray generation shader causes rays to be traced into the scene.  Depending on where the ray goes in the scene, one of several hit or miss shaders may be invoked at the point of intersection.  This allows a game to assign each object its own set of shaders and textures, resulting in a unique material.</p>
<p>The raytracing pipeline state, a companion in spirit to today’s Graphics and Compute pipeline state objects, encapsulates the raytracing shaders and other state relevant to raytracing workloads.</p>
<h2 id="0x32-Vulkan-ray-tracing"><a href="#0x32-Vulkan-ray-tracing" class="headerlink" title="0x32 Vulkan ray tracing"></a>0x32 Vulkan ray tracing</h2><p>NVIDIA提供了Vulkan的扩展了支持ray tracing。<br><a href="https://devblogs.nvidia.com/vulkan-raytracing/" target="_blank" rel="external">Vulkan ray tracing</a></p>
<h2 id="0x33-Metal-ray-tracing"><a href="#0x33-Metal-ray-tracing" class="headerlink" title="0x33 Metal ray tracing"></a>0x33 Metal ray tracing</h2><p>Metal提供了ray tracing的支持。<br><img src="/2019/03/23/How escher support physically based render/metal_ray_tracing.png" alt=""></p>
<p>详细信息请参考<br><a href="https://developer.apple.com/videos/play/wwdc2018/606/" target="_blank" rel="external">Metal ray tracing</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/16/AV1-syntax-explanation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/16/AV1-syntax-explanation/" itemprop="url">AV1-syntax-explanation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-16T17:00:10+09:00">
                2019-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/16/AV1-syntax-explanation/" class="leancloud_visitors" data-flag-title="AV1-syntax-explanation">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-解码流程介绍"><a href="#0x1-解码流程介绍" class="headerlink" title="0x1 解码流程介绍"></a>0x1 解码流程介绍</h1><p><img src="/2019/03/16/AV1-syntax-explanation/av1 syntax description.png" alt=""><br>解码流程说明如下</p>
<h2 id="0x11-tile-group-obu"><a href="#0x11-tile-group-obu" class="headerlink" title="0x11 tile_group_obu"></a>0x11 tile_group_obu</h2><p>   对tile group的每个tile调用decode_tile()进行解码，直至tile group中包括的tile都解码完成.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( TileNum = tg_start; TileNum &lt;= tg_end; TileNum++ ) &#123;</div><div class="line">    tileRow = TileNum / TileCols</div><div class="line">    tileCol = TileNum % TileCols</div><div class="line">    ......</div><div class="line">    decode_tile( )</div><div class="line">    exit_symbol( )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x12-decode-tile"><a href="#0x12-decode-tile" class="headerlink" title="0x12 decode_tile"></a>0x12 decode_tile</h2><p>   对tile中包含的每个partition进行解码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ( r = MiRowStart; r &lt; MiRowEnd; r += sbSize4 ) &#123;</div><div class="line">    <span class="keyword">for</span> ( c = MiColStart; c &lt; MiColEnd; c += sbSize4 ) &#123;</div><div class="line">        ......</div><div class="line">        decode_partition( r, c, sbSize )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x13-decode-partition"><a href="#0x13-decode-partition" class="headerlink" title="0x13 decode_partition"></a>0x13 decode_partition</h2><p>   每个partition的解码过程就是对一个super block(super block的定义参考0x2)进行解码的过程.<br>   根据partition类型对进一步split, 不能split的类型调用decode_block().</p>
<pre><code>partition类型的定义如下

| Partition index | Type of partition  |
|:-------:|:------------- |
| 0 |PARTITION_NONE|
| 1 |PARTITION_HORZ|
| 2 |PARTITION_VERT|
| 3 |PARTITION_SPLIT|
| 4 |PARTITION_HORZ_A|
| 5 |PARTITION_HORZ_B|
| 6 |PARTITION_VERT_A|
| 7 |PARTITION_VERT_B|
| 8 |PARTITION_HORZ_4|
| 9 |PARTITION_VERT_4|
</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( partition == PARTITION_NONE ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line"><span class="keyword">if</span> ( hasRows )</div><div class="line">    decode_block( r + halfBlock4x4, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    <span class="keyword">if</span> ( hasCols )</div><div class="line">       decode_block( r, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_SPLIT ) &#123;</div><div class="line">    decode_partition( r, c, subSize )</div><div class="line">    decode_partition( r, c + halfBlock4x4, subSize )</div><div class="line">    decode_partition( r + halfBlock4x4, c, subSize )</div><div class="line">    decode_partition( r + halfBlock4x4, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_A ) &#123;</div><div class="line">    decode_block( r, c, splitSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_B ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT_A ) &#123;</div><div class="line">    decode_block( r, c, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c, splitSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, subSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_VERT_B ) &#123;</div><div class="line">    decode_block( r, c, subSize )</div><div class="line">    decode_block( r, c + halfBlock4x4, splitSize )</div><div class="line">    decode_block( r + halfBlock4x4, c + halfBlock4x4, splitSize )</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ( partition == PARTITION_HORZ_4 ) &#123;</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">0</span>, c, subSize )</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">1</span>, c, subSize )</div><div class="line">    decode_block( r + quarterBlock4x4 * <span class="number">2</span>, c, subSize )</div><div class="line">    <span class="keyword">if</span> ( r + quarterBlock4x4 * <span class="number">3</span> &lt; MiRows )</div><div class="line">        decode_block( r + quarterBlock4x4 * <span class="number">3</span>, c, subSize )</div><div class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">//PARTITION_VERT_4</span></div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">0</span>, subSize )</div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">1</span>, subSize )</div><div class="line">    decode_block( r, c + quarterBlock4x4 * <span class="number">2</span>, subSize )</div><div class="line">    <span class="keyword">if</span> ( c + quarterBlock4x4 * <span class="number">3</span> &lt; MiCols )</div><div class="line">        decode_block( r, c + quarterBlock4x4 * <span class="number">3</span>, subSize )</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x14-decode-block"><a href="#0x14-decode-block" class="headerlink" title="0x14 decode_block"></a>0x14 decode_block</h2><p>   对一个block进行解码，进一步调用residual对残差进行解码.</p>
<h2 id="0x15-transform-tree"><a href="#0x15-transform-tree" class="headerlink" title="0x15 transform_tree"></a>0x15 transform_tree</h2><p>   对不同size的transform块进行解码，它是一个递归函数，递归退出函数是transform_block.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">transform_tree( startX, startY, w, h ) &#123; Type</div><div class="line">    maxX = MiCols * MI_SIZE</div><div class="line">    maxY = MiRows * MI_SIZE</div><div class="line">    <span class="keyword">if</span> ( startX &gt;= maxX || startY &gt;= maxY ) &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    row = startY &gt;&gt; MI_SIZE_LOG2</div><div class="line">    col = startX &gt;&gt; MI_SIZE_LOG2</div><div class="line">    lumaTxSz = InterTxSizes[ row ][ col ]</div><div class="line">    lumaW = Tx_Width[ lumaTxSz ]</div><div class="line">    lumaH = Tx_Height[ lumaTxSz ]</div><div class="line">    <span class="keyword">if</span> ( w &lt;= lumaW &amp;&amp; h &lt;= lumaH ) &#123;</div><div class="line">        txSz = find_tx_size( w, h )</div><div class="line">        transform_block( <span class="number">0</span>, startX, startY, txSz, <span class="number">0</span>, <span class="number">0</span> )</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ( w &gt; h ) &#123;</div><div class="line">            transform_tree( startX, startY, w/<span class="number">2</span>, h )</div><div class="line">            transform_tree( startX + w / <span class="number">2</span>, startY, w/<span class="number">2</span>, h )</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( w &lt; h ) &#123;</div><div class="line">            transform_tree( startX, startY, w, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX, startY + h/<span class="number">2</span>, w, h/<span class="number">2</span> )</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            transform_tree( startX, startY, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX + w/<span class="number">2</span>, startY, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX, startY + h/<span class="number">2</span>, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">            transform_tree( startX + w/<span class="number">2</span>, startY + h/<span class="number">2</span>, w/<span class="number">2</span>, h/<span class="number">2</span> )</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x16-Reconstruct中包括具体的反量化，反dct-重建像素和loop-filter等过程"><a href="#0x16-Reconstruct中包括具体的反量化，反dct-重建像素和loop-filter等过程" class="headerlink" title="0x16 Reconstruct中包括具体的反量化，反dct,重建像素和loop filter等过程."></a>0x16 Reconstruct中包括具体的反量化，反dct,重建像素和loop filter等过程.</h2><h1 id="0x2-super-block"><a href="#0x2-super-block" class="headerlink" title="0x2 super block"></a>0x2 super block</h1><p>下图说明了一个frame由许多super block组成，super block的定义稍后说明.<br><img src="/2019/03/16/AV1-syntax-explanation/super_block.png" alt=""></p>
<p>Super block的定义如下<br>The top level of the block quadtree within a tile. All superblocks within a frame are the same size and are square. The<br>superblocks may be 128x128 luma samples or 64x64 luma samples. A superblock may contain 1 or 2 or 4 mode info<br>blocks, or may be bisected in each direction to create 4 sub-blocks, which may themselves be further subpartitioned,<br>forming the block quadtree.</p>
<p>通过在sequence_header_obu中的use_128x128_superblock来控制superblock的大小是128x128还是64x64.<br>sequence_header_obu( ) {<br>    ……<br>    use_128x128_superblock f(1)<br>    ……<br>}</p>
<p>use_128x128_superblock的定义如下<br>when equal to 1, indicates that superblocks contain 128x128 luma samples. When equal to 0,<br>it indicates that superblocks contain 64x64 luma samples.</p>
<h1 id="0x3-split划分"><a href="#0x3-split划分" class="headerlink" title="0x3 split划分"></a>0x3 split划分</h1><p>下图显示了super block(64x64)的split状态, 从图中可以看到，64x64的block会被split到32x32，再进一步split到16x16.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/split_.png" alt=""></p>
<h1 id="0x4-Intra-Y-mode"><a href="#0x4-Intra-Y-mode" class="headerlink" title="0x4 Intra Y mode"></a>0x4 Intra Y mode</h1><p>下图显示了Intra Prediction中Y分量的mode，不同的颜色代码不同的mode.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/mode.png" alt=""></p>
<h1 id="0x5-Intra-UV-mode"><a href="#0x5-Intra-UV-mode" class="headerlink" title="0x5 Intra UV mode"></a>0x5 Intra UV mode</h1><p>下图显示了Intra Prediction中UV分量的mode，不同的颜色代码不同的mode，其中显示数字的块表示该mode为chroma from luma prediction, 其中显示的数字表示chroma需要从哪个位置的luma预测.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/uv_mode.png" alt=""></p>
<h1 id="0x6-Motion-vector"><a href="#0x6-Motion-vector" class="headerlink" title="0x6 Motion vector"></a>0x6 Motion vector</h1><p>下图显示了Inter frame帧间预测的运动向量.</p>
<p><img src="/2019/03/16/AV1-syntax-explanation/motion_vector.png" alt=""></p>
<h1 id="0x7-Reference"><a href="#0x7-Reference" class="headerlink" title="0x7 Reference"></a>0x7 Reference</h1><p><a href="https://people.xiph.org/~mbebenita/analyzer/" target="_blank" rel="external">AV1 analyzer</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/09/Synchronization-in-Vulkan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/09/Synchronization-in-Vulkan/" itemprop="url">Synchronization-in-Vulkan</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-09T17:00:10+09:00">
                2019-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/09/Synchronization-in-Vulkan/" class="leancloud_visitors" data-flag-title="Synchronization-in-Vulkan">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Overview"><a href="#0x1-Overview" class="headerlink" title="0x1 Overview"></a>0x1 Overview</h1><p>Vulkan的一大优势是能通过多线程来提升CPU bounding场景的performance，这依赖于其提供了下面几种同步机制。</p>
<p>Semaphores，用于多个queue之间的同步或者是一个queue的任务提交同步。<br>Events，用于一个command buffer内部的同步或在同一个queue内部多个command buffer的同步。<br>Fences，用于提供devive和host之间的同步。<br>barriers，用于精确控制pipeline中各个pipeline阶段的资源流动。<br>下图说明了这几种同步机制适用的场景。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/sync_types.png" alt=""></p>
<h1 id="0x2-Details"><a href="#0x2-Details" class="headerlink" title="0x2 Details"></a>0x2 Details</h1><h2 id="0x21-Pipeline-Barrier"><a href="#0x21-Pipeline-Barrier" class="headerlink" title="0x21 Pipeline Barrier"></a>0x21 Pipeline Barrier</h2><p>Barrier是一种同步机制，用来管理内存访问和同步Vulkan pipeline中各个阶段里的资源状态变化。通过这种机制来fine-grained控制command buffer执行过程中资源在pipeline的各个阶段中的流动。</p>
<p>Vulkan通过API vkCmdPipelineBarrier()来控制三种barrier操作，Memory barrier, Buffer Memory barrier和Image Memory barrier。</p>
<p>其中Memory barrier, Buffer Memory barrier会控制资源在pipeline各个阶段的执行次序。其作用有两个，<br>一个作用是控制执行顺序，对写后读(WaR)，读后写(RaW)，写后写(WaW)三种情况提供保护。另外一个作用是保证pipeline不同部分中数据的视图的一致性，因为pipeline不同stage之间可能有cache，在插入了barrier的地方需要flush cache。<br>Image Memory barrier的作用是控制对图像的访问。</p>
<p>三种barrier的数据结构如下所示<br><img src="/2019/03/09/Synchronization-in-Vulkan/pipelinebarrier.png" alt=""></p>
<p>Vulkan的pipeline包括下面这几种,Command的执行从top开始，然后执行类似VS，FS之类的pipeline，最后是bottom。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">TOP_OF_PIPE_BIT</div><div class="line">DRAW_INDIRECT_BIT</div><div class="line">VERTEX_INPUT_BIT</div><div class="line">VERTEX_SHADER_BIT</div><div class="line">TESSELLATION_CONTROL_SHADER_BIT</div><div class="line">TESSELLATION_EVALUATION_SHADER_BIT</div><div class="line">GEOMETRY_SHADER_BIT</div><div class="line">FRAGMENT_SHADER_BIT</div><div class="line">EARLY_FRAGMENT_TESTS_BIT</div><div class="line">LATE_FRAGMENT_TESTS_BIT</div><div class="line">COLOR_ATTACHMENT_OUTPUT_BIT</div><div class="line">TRANSFER_BIT</div><div class="line">COMPUTE_SHADER_BIT</div><div class="line">BOTTOM_OF_PIPE_BIT</div></pre></td></tr></table></figure>
<p>但是如何设置vkCmdPipelineBarrier中source stage和dest stage呢？ </p>
<p>最简单的方式是把source stage设置为VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT，dest stage设置为VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT。<br>这种设置会等待前面command buffer的所有pipeline都执行结束了，后面command buffer才能开始，很明显这种设置多个command buffer没有并行执行，command buffer之间只是串行的，performance应该会受到影响。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/slow-barrier.png" alt=""></p>
<p>如果希望能在多个command buffer之间并行执行，需要根据实际情况设置source stage和dest stage。</p>
<p>假如vertex shader后面接了一个compute shader, compute shader执行的时候需要读取vertex shader的执行结果，<br>我们可以把source stage设置为VK_PIPELINE_STAGE_VERTEX_SHADER_BIT，dest stage设置为VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT。<br>更详细的介绍，请参考后面的代码说明。</p>
<p>原则上source stage和dest stage的设置应该尽量使下图中的ubblocked pipeline(green stages)尽可能地多，这样并行度会越高。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/good-barrier.png" alt=""></p>
<p>Memory barrier示例代码</p>
<p>根据需要，创建两个queue(graphics queue和compute queue)和对应的command buffer.<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 创建graphics queue和command pool</span></div><div class="line">vkGetDeviceQueue(device, vulkanDevice-&gt;queueFamilyIndices.graphics, <span class="number">0</span>, &amp;<span class="built_in">queue</span>);</div><div class="line"></div><div class="line">VkCommandPoolCreateInfo cmdPoolInfo = &#123;&#125;;</div><div class="line">cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</div><div class="line">cmdPoolInfo.queueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics;</div><div class="line">cmdPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</div><div class="line">VK_CHECK_RESULT(vkCreateCommandPool(device, &amp;cmdPoolInfo, <span class="literal">nullptr</span>, &amp;cmdPool));</div><div class="line"></div><div class="line"><span class="comment">// 创建compute queue和command pool</span></div><div class="line">vkGetDeviceQueue(device, vulkanDevice-&gt;queueFamilyIndices.compute, <span class="number">0</span>, &amp;compute.<span class="built_in">queue</span>);</div><div class="line">VkCommandPoolCreateInfo cmdPoolInfo = &#123;&#125;;</div><div class="line">cmdPoolInfo.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;</div><div class="line">cmdPoolInfo.queueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute;</div><div class="line">cmdPoolInfo.flags = VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT;</div><div class="line">VK_CHECK_RESULT(vkCreateCommandPool(device, &amp;cmdPoolInfo, <span class="literal">nullptr</span>, &amp;compute.commandPool));</div></pre></td></tr></table></figure></p>
<p>下面的代码说明了如何在这两个command buffer执行的过程中插入barrier, 从而实现资源访问的控制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildComputeCommandBuffer</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	VkCommandBufferBeginInfo cmdBufInfo = vks::initializers::commandBufferBeginInfo();</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkBeginCommandBuffer(compute.commandBuffer, &amp;cmdBufInfo));</div><div class="line"></div><div class="line">	<span class="comment">// Compute particle movement</span></div><div class="line"></div><div class="line">	<span class="comment">// Add memory barrier to ensure that the (graphics) vertex shader has fetched attributes before compute starts to write to the buffer</span></div><div class="line">	VkBufferMemoryBarrier bufferBarrier = vks::initializers::bufferMemoryBarrier();</div><div class="line">	bufferBarrier.buffer = compute.storageBuffer.buffer;</div><div class="line">	bufferBarrier.size = compute.storageBuffer.descriptor.range;</div><div class="line">	bufferBarrier.srcAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;	<span class="comment">// Vertex shader invocations have finished reading from the buffer</span></div><div class="line">	bufferBarrier.dstAccessMask = VK_ACCESS_SHADER_WRITE_BIT; <span class="comment">// Compute shader wants to write to the buffer</span></div><div class="line">	<span class="comment">// Compute and graphics queue may have different queue families (see VulkanDevice::createLogicalDevice)</span></div><div class="line">	<span class="comment">// For the barrier to work across different queues, we need to set their family indices</span></div><div class="line">	bufferBarrier.srcQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics; <span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line">	bufferBarrier.dstQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute; <span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line"></div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		compute.commandBuffer,</div><div class="line">		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;bufferBarrier,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">	vkCmdBindPipeline(compute.commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipeline);</div><div class="line">	vkCmdBindDescriptorSets(compute.commandBuffer, VK_PIPELINE_BIND_POINT_COMPUTE, compute.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;compute.descriptorSet, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Dispatch the compute job</span></div><div class="line">	vkCmdDispatch(compute.commandBuffer, PARTICLE_COUNT / <span class="number">256</span>, <span class="number">1</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Add memory barrier to ensure that compute shader has finished writing to the buffer</span></div><div class="line">	<span class="comment">// Without this the (rendering) vertex shader may display incomplete results (partial data from last frame) </span></div><div class="line">	bufferBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;  <span class="comment">// Compute shader has finished writes to the buffer</span></div><div class="line">	bufferBarrier.dstAccessMask = VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT;	<span class="comment">// Vertex shader invocations want to read from the buffer</span></div><div class="line">	bufferBarrier.buffer = compute.storageBuffer.buffer;</div><div class="line">	bufferBarrier.size = compute.storageBuffer.descriptor.range;</div><div class="line">	<span class="comment">// Compute and graphics queue may have different queue families (see VulkanDevice::createLogicalDevice)</span></div><div class="line">	<span class="comment">// For the barrier to work across different queues, we need to set their family indices</span></div><div class="line">	bufferBarrier.srcQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.compute;	<span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line">	bufferBarrier.dstQueueFamilyIndex = vulkanDevice-&gt;queueFamilyIndices.graphics;	<span class="comment">// Required as compute and graphics queue may have different families</span></div><div class="line"></div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		compute.commandBuffer,</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_VERTEX_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;bufferBarrier,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>);</div><div class="line"></div><div class="line">	vkEndCommandBuffer(compute.commandBuffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Image barrier示例代码如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int32_t</span> i = <span class="number">0</span>; i &lt; drawCmdBuffers.size(); ++i)</div><div class="line">&#123;</div><div class="line">	<span class="comment">// Set target frame buffer</span></div><div class="line">	renderPassBeginInfo.framebuffer = frameBuffers[i];</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkBeginCommandBuffer(drawCmdBuffers[i], &amp;cmdBufInfo));</div><div class="line"></div><div class="line">	<span class="comment">// Image memory barrier to make sure that compute shader writes are finished before sampling from the texture</span></div><div class="line">	VkImageMemoryBarrier imageMemoryBarrier = &#123;&#125;;</div><div class="line">	imageMemoryBarrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER;</div><div class="line">	<span class="comment">// We won't be changing the layout of the image</span></div><div class="line">	imageMemoryBarrier.oldLayout = VK_IMAGE_LAYOUT_GENERAL;</div><div class="line">	imageMemoryBarrier.newLayout = VK_IMAGE_LAYOUT_GENERAL;</div><div class="line">	imageMemoryBarrier.image = textureComputeTarget.image;</div><div class="line">	imageMemoryBarrier.subresourceRange = &#123; VK_IMAGE_ASPECT_COLOR_BIT, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span> &#125;;</div><div class="line">	imageMemoryBarrier.srcAccessMask = VK_ACCESS_SHADER_WRITE_BIT;</div><div class="line">	imageMemoryBarrier.dstAccessMask = VK_ACCESS_SHADER_READ_BIT;</div><div class="line">	vkCmdPipelineBarrier(</div><div class="line">		drawCmdBuffers[i],</div><div class="line">		VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT,</div><div class="line">		VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT,</div><div class="line">		VK_FLAGS_NONE,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">0</span>, <span class="literal">nullptr</span>,</div><div class="line">		<span class="number">1</span>, &amp;imageMemoryBarrier);</div><div class="line">	vkCmdBeginRenderPass(drawCmdBuffers[i], &amp;renderPassBeginInfo, VK_SUBPASS_CONTENTS_INLINE);</div><div class="line"></div><div class="line">	VkViewport viewport = vks::initializers::viewport((<span class="keyword">float</span>)width * <span class="number">0.5f</span>, (<span class="keyword">float</span>)height, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</div><div class="line">	vkCmdSetViewport(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</div><div class="line"></div><div class="line">	VkRect2D scissor = vks::initializers::rect2D(width, height, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">	vkCmdSetScissor(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;scissor);</div><div class="line"></div><div class="line">	VkDeviceSize offsets[<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</div><div class="line">	vkCmdBindVertexBuffers(drawCmdBuffers[i], VERTEX_BUFFER_BIND_ID, <span class="number">1</span>, &amp;vertexBuffer.buffer, offsets);</div><div class="line">	vkCmdBindIndexBuffer(drawCmdBuffers[i], indexBuffer.buffer, <span class="number">0</span>, VK_INDEX_TYPE_UINT32);</div><div class="line"></div><div class="line">	<span class="comment">// Left (pre compute)</span></div><div class="line">	vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;graphics.descriptorSetPreCompute, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);</div><div class="line"></div><div class="line">	vkCmdDrawIndexed(drawCmdBuffers[i], indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">// Right (post compute)</span></div><div class="line">	vkCmdBindDescriptorSets(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipelineLayout, <span class="number">0</span>, <span class="number">1</span>, &amp;graphics.descriptorSetPostCompute, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">	vkCmdBindPipeline(drawCmdBuffers[i], VK_PIPELINE_BIND_POINT_GRAPHICS, graphics.pipeline);</div><div class="line"></div><div class="line">	viewport.x = (<span class="keyword">float</span>)width / <span class="number">2.0f</span>;</div><div class="line">	vkCmdSetViewport(drawCmdBuffers[i], <span class="number">0</span>, <span class="number">1</span>, &amp;viewport);</div><div class="line">	vkCmdDrawIndexed(drawCmdBuffers[i], indexCount, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	vkCmdEndRenderPass(drawCmdBuffers[i]);</div><div class="line"></div><div class="line">	VK_CHECK_RESULT(vkEndCommandBuffer(drawCmdBuffers[i]));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="0x22-Semaphore-Event-Fence"><a href="#0x22-Semaphore-Event-Fence" class="headerlink" title="0x22 Semaphore/Event/Fence"></a>0x22 Semaphore/Event/Fence</h2><p>下面说明并行渲染多帧时采用的同步机制。</p>
<p><img src="/2019/03/09/Synchronization-in-Vulkan/frame_sync.png" alt=""></p>
<p>如上图所示，当swap chain中的image可用时，vkAcquireNextImageKHR会触发一个semaphore a，vkQueueSubmit拿到这个semaphore b以后开始执行command buffer的命令，执行command buffer的过程中会往vkAcquireNextImageKHR得到的image(这个image类似于frame buffer的概念)中写内容，执行完毕以后会触发semaphore b, vkQueuePresentKHR等待这个semaphore b触发以后就把image的内容绘制到display上。<br>当第N frame在Submit任务到GPU上执行的时候， (N+1)frame同时在CPU上开启多线程往多个command buffer中生成command，这样CPU和GPU相互配合，提升performance。</p>
<p>下面说明渲染一帧时内部采用的同步机制。<br><img src="/2019/03/09/Synchronization-in-Vulkan/sync-example.png" alt=""></p>
<p>上图中第一个vkQueueSubmit的参数如下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</div><div class="line">   <span class="comment">// 执行vkQueueSubmit的wait semaphore，等待其触发，其已经在vkAcquireNextImageKHR中触发</span></div><div class="line">submitInfo.pWaitSemaphores = &amp;semaphores.presentComplete;</div><div class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</div><div class="line">   <span class="comment">// vkQueueSubmit执行完以后的signal semaphore</span></div><div class="line">submitInfo.pSignalSemaphores = &amp;semaphores.renderComplete;</div><div class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</div><div class="line">submitInfo.pCommandBuffers = &amp;primaryCommandBuffer;</div><div class="line"></div><div class="line">VK_CHECK_RESULT(vkQueueSubmit(<span class="built_in">queue</span>, <span class="number">1</span>, &amp;submitInfo, renderFence));</div></pre></td></tr></table></figure></p>
<p>然后执行vKQueuePresentKHR，这边的wait semaphore是前面一步的renderComplete, 表明只有renderComplete被触发以后vKQueuePresentKHR才能被执行。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">VK_CHECK_RESULT(swapChain.queuePresent(<span class="built_in">queue</span>, currentBuffer, submitTextOverlay ? semaphores.textOverlayComplete : semaphores.renderComplete));</div></pre></td></tr></table></figure></p>
<p>上面虚线部分表明在执行vKQueuePresentKHR之间，还有一个text overlay command buffer需要执行。<br>这个command buffer的wait semaphore为renderComplete。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Set semaphores</span></div><div class="line"><span class="comment">// Wait for render complete semaphore</span></div><div class="line">submitInfo.waitSemaphoreCount = <span class="number">1</span>;</div><div class="line">submitInfo.pWaitSemaphores = &amp;semaphores.renderComplete;</div><div class="line"><span class="comment">// Signal ready with text overlay complete semaphpre</span></div><div class="line">submitInfo.signalSemaphoreCount = <span class="number">1</span>;</div><div class="line">submitInfo.pSignalSemaphores = &amp;semaphores.textOverlayComplete;</div><div class="line"></div><div class="line"><span class="comment">// Submit current text overlay command buffer</span></div><div class="line">submitInfo.commandBufferCount = <span class="number">1</span>;</div><div class="line">submitInfo.pCommandBuffers = &amp;textOverlay-&gt;cmdBuffers[currentBuffer];</div><div class="line">VK_CHECK_RESULT(vkQueueSubmit(<span class="built_in">queue</span>, <span class="number">1</span>, &amp;submitInfo, VK_NULL_HANDLE));</div></pre></td></tr></table></figure>
<h1 id="0x3-References"><a href="#0x3-References" class="headerlink" title="0x3 References"></a>0x3 References</h1><p><a href="https://gpuopen.com/vulkan-barriers-explained/" target="_blank" rel="external">Vulkan barriers explained</a><br><a href="https://community.arm.com/developer/tools-software/graphics/b/blog/posts/multi-threading-in-vulkan" target="_blank" rel="external">Multi-Threading in Vulkan</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/The-overview-of-AV1-coding/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kevin Wen">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kevin Wen's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/02/The-overview-of-AV1-coding/" itemprop="url">The overview of AV1 coding</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-02T20:00:10+09:00">
                2019-03-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2019/03/02/The-overview-of-AV1-coding/" class="leancloud_visitors" data-flag-title="The overview of AV1 coding">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0x1-Overview"><a href="#0x1-Overview" class="headerlink" title="0x1 Overview"></a>0x1 Overview</h1><p>AOMedia Video 1 (AV1) is an open, royalty-free video coding format, it was in particular motivated by the high cost and uncertainty of HEVC patent licensing, it aims to provide royalty-free and high compression ratio video codec.</p>
<p>This blog will give us the overview of AV1 codec, this material is from the internet, you can find the link url in the reference part.</p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/The_Technology_Inside_Av1.svg" alt="ovewview"></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/codec_overview.png" alt="ovewview"></p>
<h1 id="0x2-Partition"><a href="#0x2-Partition" class="headerlink" title="0x2 Partition"></a>0x2 Partition</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/partition1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/partition2.png" alt=""></p>
<h1 id="0x3-Intra-Prediction"><a href="#0x3-Intra-Prediction" class="headerlink" title="0x3 Intra Prediction"></a>0x3 Intra Prediction</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/intra_preditction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/smooth_intra_prediction_modes.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/chroma_from_luma.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/palette_mode.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/intra_block_copying.png" alt=""></p>
<h1 id="0x04-Inter-Prediction"><a href="#0x04-Inter-Prediction" class="headerlink" title="0x04 Inter Prediction"></a>0x04 Inter Prediction</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/inter_prediction1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/inter_prediction2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/extended_reference_frames.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/motion_vector_prediction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/dynamic_motion_vector_referencing.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/obmc.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/masked_compound_prediction.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/warped_mc.png" alt=""></p>
<h1 id="0x05-Transform-coding"><a href="#0x05-Transform-coding" class="headerlink" title="0x05 Transform coding"></a>0x05 Transform coding</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/transform1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform_kernel.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/transform_block_partitioning.png" alt=""></p>
<h1 id="0x06-Quantization"><a href="#0x06-Quantization" class="headerlink" title="0x06 Quantization"></a>0x06 Quantization</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/quantization.png" alt=""></p>
<h1 id="0x7-Entropy-coding"><a href="#0x7-Entropy-coding" class="headerlink" title="0x7 Entropy coding"></a>0x7 Entropy coding</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/entropy_coding1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/entropy_coding2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/av1_symbol_coding.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/level-map coefficient coding.png" alt=""></p>
<h1 id="0x8-Filter"><a href="#0x8-Filter" class="headerlink" title="0x8 Filter"></a>0x8 Filter</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/filtering1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/filtering2.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/cdef.png.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_filter.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_filter1.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/in_loop_sp.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/film_grain_synthesis.png" alt=""></p>
<h1 id="0x8-Efficiency-and-Complexity"><a href="#0x8-Efficiency-and-Complexity" class="headerlink" title="0x8 Efficiency and Complexity"></a>0x8 Efficiency and Complexity</h1><p><img src="/2019/03/02/The-overview-of-AV1-coding/compression_efficiency.png" alt=""></p>
<p><img src="/2019/03/02/The-overview-of-AV1-coding/coding_complexity.png" alt=""></p>
<h1 id="0x9-Reference"><a href="#0x9-Reference" class="headerlink" title="0x9 Reference"></a>0x9 Reference</h1><p><a href="https://www.youtube.com/watch?v=04lXWMcwdXA&amp;t=822s" target="_blank" rel="external">a technial overview of the AV1</a><br><a href="https://www.youtube.com/watch?v=qubPzBcYCTw&amp;t=1957s" target="_blank" rel="external">The AV1 Video Codec</a><br><a href="https://en.wikipedia.org/wiki/AV1" target="_blank" rel="external">AV1 wiki</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Kevin Wen" />
          <p class="site-author-name" itemprop="name">Kevin Wen</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">31</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kevin Wen</span>
</div>


<div> <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
访问量 <span id="busuanzi_value_site_pv"></span>
访问人数 <span id="busuanzi_value_site_uv"></span>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("orq8xxsDQDXKiHdqSRcjlflB-gzGzoHsz", "ecCFdIcWDfbJKQOCiLFf1EBm");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
